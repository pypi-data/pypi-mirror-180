# fmt: off
# Generated by the protocol buffer compiler.  DO NOT EDIT!
from __future__ import annotations
from datetime import datetime, timedelta
import enum
from typing import Any, Dict, List, Optional, TypeVar, Type
from google.protobuf import timestamp_pb2
from google.protobuf import duration_pb2
from google.protobuf.json_format import MessageToDict

from continual.rpc.logging.v1 import logging_pb2

from continual.rpc.management.v1 import types as management_v1
from google import protobuf

T = TypeVar("T")

def _to_proto_dict(x: dict) -> dict:
    """Converts dict to proto friendly representation."""
    out = dict()
    for key, item in x.items():
        if isinstance(item, list):
            out_list = []
            for e in item:
                if isinstance(e, datetime):
                    dt = timestamp_pb2.Timestamp()
                    dt.FromDatetime(e)
                    out_list.append(dt)
                elif isinstance(e, timedelta):
                    td = duration_pb2.Duration()
                    td.FromTimedelta(e)
                    out_list.append(td)
                elif hasattr(e, "to_proto"):
                    out_list.append(e.to_proto())
                else:
                    out_list.append(e)
            out[key] = out_list
        elif isinstance(item, datetime):
            dt = timestamp_pb2.Timestamp()
            dt.FromDatetime(item)
            out[key] = dt
        elif isinstance(item, timedelta):
            td = duration_pb2.Duration()
            td.FromTimedelta(item)
            out[key] = td
        elif hasattr(item, "to_proto"):
            out[key] = item.to_proto()
        else:
            out[key] = item
    return out


def _set_attribute(
    attributes: dict, class_name: str, field: str, value: Any, fieldType: Any, oneOfField: str
):
    """Helper that sets attribute on the object.
    
    Accepts dicts for classes and normalizes enums.
    """
    if isinstance(value, dict) and getattr(fieldType, "__origin__", None) == dict:
        attributes[field] = value
    elif isinstance(value, dict):
        attributes[field] = fieldType(**value)
    elif isinstance(value, list):
        innerType = fieldType.__args__[0]
        if innerType in [str, float, bool]:
            attributes[field] = value
        elif innerType is int:
            attributes[field] = [int(x) for x in value]
        elif issubclass(innerType, Enum):
            if len(value) > 0:
                if isinstance(value[0], str):
                    attributes[field] = [innerType(x.upper()) for x in value]
                elif isinstance(value[0], int) and getattr(innerType, "from_proto", None) is not None:
                    attributes[field] = [innerType.from_proto(x) for x in value]
        else:
            attributes[field] = [innerType(**x) for x in value]
    elif isinstance(value, str) and issubclass(fieldType, Enum):
        attributes[field] = fieldType(value.upper())
    elif isinstance(value, int) and issubclass(fieldType, Enum) and getattr(fieldType, "from_proto", None) is not None:
        attributes[field] = fieldType.from_proto(value)
    elif isinstance(value, str) and fieldType == datetime:
        dt = timestamp_pb2.Timestamp()
        dt.FromJsonString(value)
        attributes[field] = dt.ToDatetime()
    elif isinstance(value, str) and fieldType == timedelta:
        td = timestamp_pb2.Duration()
        td.FromJsonString(value)
        attributes[field] = td.ToTimeDelta()
    elif isinstance(value, str) and fieldType == int:
        # Needed to handle int64 encoded as strings.
        attributes[field] = int(value)
    # Set zero values to be consistent with proto.
    elif value is None:
        if fieldType == str:
            attributes[field] = ""
        elif fieldType == int:
            attributes[field] = 0
        elif fieldType == float:
            attributes[field] = 0.0
        elif fieldType == bool:
            attributes[field] = False
        elif getattr(fieldType, "__origin__", None) == list:
            attributes[field] = []
        elif getattr(fieldType, "__origin__", None) == dict:
            attributes[field] = {}
        elif fieldType == datetime or fieldType == timedelta:
            attributes[field] = None
        else:
            if oneOfField == "":
                attributes[field] = fieldType()
            else:
                attributes[field] = None
    elif value is not None and not isinstance(value, fieldType):
        raise ValueError(
            f"'{class_name}.{field}' must have type {fieldType}, got {type(value)}"
        )
    else:
        attributes[field] = value


class Enum(enum.Enum):
    """Base enum class.
    
    Overrides equality to be case insentitive.
    """

    def __eq__(self, other) -> bool:
        """Object is equal with all types."""
        if isinstance(other, str):
            return self.name == other.upper()
        elif isinstance(other, int):
            return self.value == other
        else:
            return self.value == other.value
    
    def __str__(self) -> str:
        return self.value




class LogHeartbeatRequest:
    """Log heartbeat request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , resource: str = ""
    , **kwargs) -> LogHeartbeatRequest:
        self._attributes = dict()
        self.resource = resource

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def resource(self) -> str:
        """Resource."""
        return self._attributes["resource"]


    @resource.setter
    def resource(self, value: str) -> None:
        _set_attribute(self._attributes, "LogHeartbeatRequest", "resource", value, str, "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogHeartbeatRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogHeartbeatRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogHeartbeatRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogHeartbeatRequest object " + repr(self.to_dict()) + ">"


class LogExperimentsRequest:
    """Log experiments request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , model_version: str = ""
        , experiments: List[management_v1.Experiment] = []
    , **kwargs) -> LogExperimentsRequest:
        self._attributes = dict()
        self.model_version = model_version
        self.experiments = experiments

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def model_version(self) -> str:
        """Model version."""
        return self._attributes["model_version"]


    @model_version.setter
    def model_version(self, value: str) -> None:
        _set_attribute(self._attributes, "LogExperimentsRequest", "model_version", value, str, "")


    @property
    def experiments(self) -> List[management_v1.Experiment]:
        """Experiments."""
        return self._attributes["experiments"]


    @experiments.setter
    def experiments(self, value: List[management_v1.Experiment]) -> None:
        _set_attribute(self._attributes, "LogExperimentsRequest", "experiments", value, List[management_v1.Experiment], "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogExperimentsRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogExperimentsRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogExperimentsRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogExperimentsRequest object " + repr(self.to_dict()) + ">"


class LogMetricsRequest:
    """Log metrics request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , resource: str = ""
        , metrics: List[management_v1.Metric] = []
    , **kwargs) -> LogMetricsRequest:
        self._attributes = dict()
        self.resource = resource
        self.metrics = metrics

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def resource(self) -> str:
        """Resource."""
        return self._attributes["resource"]


    @resource.setter
    def resource(self, value: str) -> None:
        _set_attribute(self._attributes, "LogMetricsRequest", "resource", value, str, "")


    @property
    def metrics(self) -> List[management_v1.Metric]:
        """Metrics."""
        return self._attributes["metrics"]


    @metrics.setter
    def metrics(self, value: List[management_v1.Metric]) -> None:
        _set_attribute(self._attributes, "LogMetricsRequest", "metrics", value, List[management_v1.Metric], "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogMetricsRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogMetricsRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogMetricsRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogMetricsRequest object " + repr(self.to_dict()) + ">"


class LogDataProfileRequest:
    """Log data profile request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , resource: str = ""
        , data_profile: management_v1.DataProfile = None
    , **kwargs) -> LogDataProfileRequest:
        self._attributes = dict()
        self.resource = resource
        self.data_profile = data_profile

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def resource(self) -> str:
        """Resource."""
        return self._attributes["resource"]


    @resource.setter
    def resource(self, value: str) -> None:
        _set_attribute(self._attributes, "LogDataProfileRequest", "resource", value, str, "")


    @property
    def data_profile(self) -> management_v1.DataProfile:
        """Data profile."""
        return self._attributes["data_profile"]


    @data_profile.setter
    def data_profile(self, value: management_v1.DataProfile) -> None:
        _set_attribute(self._attributes, "LogDataProfileRequest", "data_profile", value, management_v1.DataProfile, "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogDataProfileRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogDataProfileRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogDataProfileRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogDataProfileRequest object " + repr(self.to_dict()) + ">"


class LogDataChecksRequest:
    """Log data checks request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , resource: str = ""
        , data_checks: List[management_v1.DataCheck] = []
    , **kwargs) -> LogDataChecksRequest:
        self._attributes = dict()
        self.resource = resource
        self.data_checks = data_checks

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def resource(self) -> str:
        """Resource."""
        return self._attributes["resource"]


    @resource.setter
    def resource(self, value: str) -> None:
        _set_attribute(self._attributes, "LogDataChecksRequest", "resource", value, str, "")


    @property
    def data_checks(self) -> List[management_v1.DataCheck]:
        """Data checks."""
        return self._attributes["data_checks"]


    @data_checks.setter
    def data_checks(self, value: List[management_v1.DataCheck]) -> None:
        _set_attribute(self._attributes, "LogDataChecksRequest", "data_checks", value, List[management_v1.DataCheck], "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogDataChecksRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogDataChecksRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogDataChecksRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogDataChecksRequest object " + repr(self.to_dict()) + ">"


class LogModelVersionRequest:
    """Log model version request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , model_version: management_v1.ModelVersion = None
        , update_paths: List[str] = []
    , **kwargs) -> LogModelVersionRequest:
        self._attributes = dict()
        self.model_version = model_version
        self.update_paths = update_paths

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def model_version(self) -> management_v1.ModelVersion:
        """Model version."""
        return self._attributes["model_version"]


    @model_version.setter
    def model_version(self, value: management_v1.ModelVersion) -> None:
        _set_attribute(self._attributes, "LogModelVersionRequest", "model_version", value, management_v1.ModelVersion, "")


    @property
    def update_paths(self) -> List[str]:
        """Update paths."""
        return self._attributes["update_paths"]


    @update_paths.setter
    def update_paths(self, value: List[str]) -> None:
        _set_attribute(self._attributes, "LogModelVersionRequest", "update_paths", value, List[str], "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogModelVersionRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogModelVersionRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogModelVersionRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogModelVersionRequest object " + repr(self.to_dict()) + ">"


class LogBatchPredictionRequest:
    """Log batch prediction request."""

    _attributes: dict
    _client: Any = None
    
    def __init__(self
        , batch_prediction: management_v1.BatchPrediction = None
        , update_paths: List[str] = []
    , **kwargs) -> LogBatchPredictionRequest:
        self._attributes = dict()
        self.batch_prediction = batch_prediction
        self.update_paths = update_paths

        if "client" in kwargs:
            self._client = kwargs["client"]
        if "parent_run" in kwargs:
            self._parent_run = kwargs["parent_run"]
        if hasattr(self, "_init"):
            self._init()


    @property
    def batch_prediction(self) -> management_v1.BatchPrediction:
        """Batch prediction."""
        return self._attributes["batch_prediction"]


    @batch_prediction.setter
    def batch_prediction(self, value: management_v1.BatchPrediction) -> None:
        _set_attribute(self._attributes, "LogBatchPredictionRequest", "batch_prediction", value, management_v1.BatchPrediction, "")


    @property
    def update_paths(self) -> List[str]:
        """Update paths."""
        return self._attributes["update_paths"]


    @update_paths.setter
    def update_paths(self, value: List[str]) -> None:
        _set_attribute(self._attributes, "LogBatchPredictionRequest", "update_paths", value, List[str], "")


    @classmethod
    def from_proto(cls: Type[T], proto: logging_pb2.LogBatchPredictionRequest, **kwargs) -> T:
        """Convert object from proto representation."""
        return cls(**MessageToDict(proto, preserving_proto_field_name=True), **kwargs)

    def to_proto(self) -> logging_pb2.LogBatchPredictionRequest:
        """Convert object to proto representation."""
        return logging_pb2.LogBatchPredictionRequest(**_to_proto_dict(self._attributes))

    def to_dict(self) -> dict:
        """Convert object to plain python dictionary representation."""
        return MessageToDict(
            self.to_proto(), 
            including_default_value_fields=True, 
            preserving_proto_field_name=True,
        )
    
    def __repr__(self) -> str:
        return "<LogBatchPredictionRequest object " + repr(self.to_dict()) + ">"
