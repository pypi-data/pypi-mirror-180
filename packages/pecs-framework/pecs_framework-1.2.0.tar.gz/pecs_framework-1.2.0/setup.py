# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pecs_framework', 'pecs_framework.entities']

package_data = \
{'': ['*']}

install_requires = \
['beartype>=0.11.0,<0.12.0',
 'deepmerge==1.0.1',
 'numpy>=1.23.4,<2.0.0',
 'pytest>=7.2.0,<8.0.0',
 'rich>=12.6.0,<13.0.0']

setup_kwargs = {
    'name': 'pecs-framework',
    'version': '1.2.0',
    'description': 'The ✨Respectably Muscled✨ Python Entity Component System',
    'long_description': '# PECS\n[![Tests](https://github.com/krummja/PECS/actions/workflows/main.yml/badge.svg)](https://github.com/krummja/PECS/actions/workflows/main.yml) [![Coverage Status](https://coveralls.io/repos/github/krummja/PECS/badge.svg?branch=master)](https://coveralls.io/github/krummja/PECS?branch=master)\n\n![Armstrong](/static/lm_pecs_armstrong.png)\n\nPECS is the ✨Respectably Muscled✨ Python ECS library that aims to provide a powerful, user-friendly, and fast-as-hell framework for game development.\n\nThis library is the spiritual successor to my prior ECS library, [ECStremity](https://github.com/krummja/ECStremity). Both this and its predecessor were inspired by the JavaScript ECS library [geotic](https://github.com/ddmills/geotic), created and maintained by [@ddmills](https://github.com/ddmills). I highly recommend checking out that project as well as the excellent resources cited in its README.\n\nWhat is ECS, you ask? [Check it out](https://medium.com/ingeniouslysimple/entities-components-and-systems-89c31464240d)!\n\n## Installation\n\nInstall the package from PyPI using pip:\n\n```\npip install pecs-framework\n```\n\nOr grab it directly from this repository:\n\n```\npip install git+https://github.com/krummja/PECS\n```\n\n## Usage and Examples\n\nTo start flexing your PECS, import the library and set up some components. Components can be built as standard Python classes:\n\n```python\nimport pecs_framework as pecs\n\n\nclass Position(pecs.Component):\n    """Representation of an Entity\'s position in 2D space."""\n\n    def __init__(self, x: int = 0, y: int = 0) -> None:\n        self.x = x\n        self.y = y\n\n    @property\n    def xy(self) -> tuple[int, int]:\n        return self.x, self.y\n```\n\nAs extensions of existing components:\n\n```py\nimport pecs_framework as pecs\n\n\nclass Velocity(Position):\n    """Representation of an Entity\'s velocity in 2D space."""\n\n```\n\nOr as dataclasses:\n\n```py\nimport pecs_framework as pecs\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Health(pecs.Component):\n    """Representation of an Entity\'s health."""\n    maximum: int = 100\n    current: int = field(init=False)\n\n    def __post_init__(self) -> None:\n        self.current = self.maximum\n```\n\nComponents can have as much or as little behavior as needed, although it is generally better to keep to a strict single-repsonsibility principle. We can even have components that have no behavior at all, representing boolean flags for queries:\n\n```py\nimport pecs_framework as pecs\n\n\nclass IsFrozen(pecs.Component):\n    """Flag component denoting a frozen entity."""\n```\n\n\n### Queries\n\nThe easiest way to build out systems is through world queries. To make a system that tracks and updates the components relevant to movement, we might query for `Position` and `Velocity` components. Because we want our entities to move, we want to exclude those marked with the `IsFrozen` flag. Perhaps we also want to grab only those entities that can fly through `Wings` or swim through `Fins`: \n\n```python\nimport pecs_framework as pecs\n\n\necs = pecs.Engine()\ndomain = ecs.create_domain("World")\n\nkinematics = domain.create_query(\n    all_of = [\n        Position, \n        Velocity\n    ],\n    any_of = [\n        Wings, \n        Fins\n    ],\n    none_of = [\n        IsFrozen\n    ],\n)\n```\n\nQueries can specify `all_of`, `any_of`, or `none_of` quantifiers. The query in the example above asks for entities that must have **both** `Position` **and** `Velocity`, may have (inclusive) `Wings` **or** `Fins`, and **must not** have `IsFrozen`.\n\nWe can access the result set of the query and do some operation on them every loop cycle:\n\n```py\ndef process(dt):\n    for entity in targets.result:\n        entity[Position].x += entity[Velocity].x * dt\n        entity[Position].y += entity[Velocity].y * dt\n```\n\nFor convenience, the library provides barebones system class that you can extend for your own purposes:\n\n```py\nimport pecs_framework as pecs\n\n\nclass MovementSystem(pecs.BaseSystem):\n\n    def initialize(self) -> None:\n        self.query(\n            \'movable\',\n            all_of = [Position, Velocity],\n            none_of = [IsFrozen],\n        )\n\n    def update(self) -> None:\n        movables = self._queries\n        for entity in movables:\n            entity[Position].x += entity[Velocity].x\n            entity[Position].y += entity[Velocity].y\n```\n\n> ---\n> \n> **Warning:** \n> \n> Do not override the `__init__` method of `BaseSystem` -- use the provided `initialize` method instead.\n> \n> --- \n\n\n### Broadcasting Events to Components\n\nComplex interactions within and among entities can be achieved by firing events on an entity. This creates an `EntityEvent` that looks for methods on all of the entity\'s methods prefixed with `on_`.\n\n```python\nzombie.fire_event(\'attack\', {\n    \'target\': survivor,\n    \'multiplier\': 1.5,\n})\n```\n\nOn the `zombie` entity, we might have attached an `Attacker` component with the following logic:\n\n```python\nclass Attacker(pecs.Component):\n\n    def __init__(self, strength: int) -> None:\n        self.strength = strength\n\n    def on_attack(self, evt: pecs.EntityEvent) -> pecs.EntityEvent:\n        target: Entity = evt.data.target\n        target.fire_event(\'damage_taken\', {\n            \'amount\': self.strength * evt.data.pultiplier,\n        })\n        evt.handle()\n        return evt\n```\n\nWhen we execute `fire_event` with the event name `attack`, the event system will find all `on_attack` methods on that entity\'s components. If we want the event propagation to stop at a particular component, we can call `evt.handle()` which will immediately break broadcasting down the component list. This means that we can potentially have any number of components respond to a specific event, although it may generally be safer to fire a secondary event to prevent ordering issues.\n\nInternally, the `EntityEvent` class puts together an instance of the class `EventData`, which provides access to the properties defined in the `fire_event` call.\n\n```python\nzombie.fire_event(\'attack\', {\n    \'target\': survivor,                 # <-- We defined \'target\' here\n    \'multiplier\': 1.5                   # <-- and \'multiplier\' here\n})\n\ndef on_attack(self, evt: pecs.EntityEvent) -> pecs.EntityEvent:\n    target = evt.data.target            # --> survivor\n    multiplier = evt.data.multiplier    # --> 1.5\n```\n\nActions can also be defined as a tuple and passed into the `fire_event` method. This allows for easy abstraction over variables used in the event:\n\n```python\nattack_against = (lambda target : (\'attack\', {\n    \'target\': target,\n    \'multiplier\': 1.5\n}))\n\nzombie.fire_event(attack_against(survivor))\n```\n\n### Creating Entities from Prefabs\n\nPECS supports defining prefab entities with preconfigured component properties. Define prefabs as `.json` files and register them with the engine:\n\n```json\n{\n  "name": "GameObject",\n  "inherit": [],\n  "components": [\n    {\n      "type": "Position"\n    },\n    {\n      "type": "Renderable",\n      "properties": {\n        "ch": "?",\n        "bg": [0, 0, 0],\n      }\n    },\n    {\n      "type": "Noun"\n    }\n  ]\n}\n```\n\n```py\nimport pecs_framework as pecs\nimport os\n\n\nROOTDIR = os.path.dirname(__file__)\nPREFABS = os.path.join(ROOTDIR, \'prefabs\')\n\n\necs = pecs.Engine()\necs.prefabs.register(PREFABS, \'game_object\')\n```\n\nNow PECS will look for a file named `game_object.json` in the specified prefabs path and automatically load it for you. We can build an entity using this prefab very easily:\n\n```py\ngame_object = ecs.domain.entities.create_from_prefab(\n    template = \'GameObject\',\n    properties = {\n        \'Position\': {\n            \'x\': 15,\n            \'y\': 10,\n        },\n        \'Renderable\': {\n            \'fg\': [255, 0, 255],\n        },\n        \'Noun\': {\n            \'text\': \'Test Object\'\n        }\n    },\n    alias = \'test_object_01\',\n)\n```\n\nPrefabs can specify other prefabs to inherit from as well. Prefabs can be defined as hierarchies of any depth and breadth. Note that properties will always be resolved from the most deeply embedded prefab to the least, overwriting with the most recent specification. If no properties are passed in the prefab or when creating from prefab, defaults from the component itself will be used.\n\nFor examples, check out the `tests` folder in this repository.\n',
    'author': 'Jonathan Crum',
    'author_email': 'crumja4@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/krummja/PECS',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8, !=2.7.*, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*, !=3.6.*, !=3.7.*',
}


setup(**setup_kwargs)
