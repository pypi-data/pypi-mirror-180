# coding: utf-8

"""
    redislabs-cnm

    null  # noqa: E501

    OpenAPI spec version: 0.90
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def v1_actions_action_uid_get(self, **kwargs):  # noqa: E501
        """v1_actions_action_uid_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_actions_action_uid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_actions_action_uid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_actions_action_uid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_actions_action_uid_get_with_http_info(self, **kwargs):  # noqa: E501
        """v1_actions_action_uid_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_actions_action_uid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_actions_action_uid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/actions/(action_uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_actions_get(self, **kwargs):  # noqa: E501
        """Get the status of all currently executing, pending or completed actions on all entities (cluster, nodes and bdbs). This API is used to track every long-lived API request which returns either a task_id or an action_uid.  # noqa: E501

        /actions/(action_uid) Returns information regarding a single action with the given uid.  See /nodes/(node_uid)/actions for reference of the ‘actions’ object.  The ‘state-machine’ object contains a list of pending, active, completed and failed state-machines.  The following attributes appear for each such state-machine:  Name  Value  action_uid  A globally unique identifier of the action.  object_name  Name of the object being manipulated by the state-machine.  status  ‘pending’ (didn’t start yet), ‘active’, ‘completed’ or ‘failed’.  name  Name of the running (or failed) state-machine.  state  Current state within the state-machine, when known.  error  A descriptive error string for failed state-machine, when known.  Regardless of an action’s source, each info entry is ‘homogenized’ to contain the following attributes: ‘name’, ‘action_uid’, ‘status’ and ‘progress’.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_actions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_actions_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_actions_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_actions_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the status of all currently executing, pending or completed actions on all entities (cluster, nodes and bdbs). This API is used to track every long-lived API request which returns either a task_id or an action_uid.  # noqa: E501

        /actions/(action_uid) Returns information regarding a single action with the given uid.  See /nodes/(node_uid)/actions for reference of the ‘actions’ object.  The ‘state-machine’ object contains a list of pending, active, completed and failed state-machines.  The following attributes appear for each such state-machine:  Name  Value  action_uid  A globally unique identifier of the action.  object_name  Name of the object being manipulated by the state-machine.  status  ‘pending’ (didn’t start yet), ‘active’, ‘completed’ or ‘failed’.  name  Name of the running (or failed) state-machine.  state  Current state within the state-machine, when known.  error  A descriptive error string for failed state-machine, when known.  Regardless of an action’s source, each info entry is ‘homogenized’ to contain the following attributes: ‘name’, ‘action_uid’, ‘status’ and ‘progress’.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_actions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_actions_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_alerts_get(self, **kwargs):  # noqa: E501
        """Get all alert states for all bdbs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each BDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_alerts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_alerts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for all bdbs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each BDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_alerts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_alerts_intuid_alert_get(self, uid, alert, **kwargs):  # noqa: E501
        """Get bdb alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_alert_get(uid, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_alerts_intuid_alert_get_with_http_info(uid, alert, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_alerts_intuid_alert_get_with_http_info(uid, alert, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_alerts_intuid_alert_get_with_http_info(self, uid, alert, **kwargs):  # noqa: E501
        """Get bdb alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_alert_get_with_http_info(uid, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'alert']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_alerts_intuid_alert_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_alerts_intuid_alert_get`")  # noqa: E501
        # verify the required parameter 'alert' is set
        if ('alert' not in params or
                params['alert'] is None):
            raise ValueError("Missing the required parameter `alert` when calling `v1_bdbs_alerts_intuid_alert_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'alert' in params:
            path_params['alert'] = params['alert']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/alerts/(int:uid)/(alert)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_alerts_intuid_get(self, **kwargs):  # noqa: E501
        """Get all alert states for bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_alerts_intuid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_alerts_intuid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_alerts_intuid_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_alerts_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/alerts/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_alerts_intuid_post(self, uid, **kwargs):  # noqa: E501
        """Updates database’s one or many alerts configuration  # noqa: E501

        The request must contain a single JSON bdb object with one or many database alert objects in it. Each alert configuration object must be according to the following schema  If passed with the dry_run URL query string, the function will validate the alert thresholds, but not commit them  The response includes the updated database alerts.  **Example request for database with ID=1** :  The above request is an attempt to modify 6 different alerts for database with ID=1.  See Object Attributes for more details on additional database alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The database ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_alerts_intuid_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_alerts_intuid_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_alerts_intuid_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Updates database’s one or many alerts configuration  # noqa: E501

        The request must contain a single JSON bdb object with one or many database alert objects in it. Each alert configuration object must be according to the following schema  If passed with the dry_run URL query string, the function will validate the alert thresholds, but not commit them  The response includes the updated database alerts.  **Example request for database with ID=1** :  The above request is an attempt to modify 6 different alerts for database with ID=1.  See Object Attributes for more details on additional database alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_alerts_intuid_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The database ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_alerts_intuid_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_alerts_intuid_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/alerts/(int:uid)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_bdb_uid_peer_stats_get(self, bdb_uid, **kwargs):  # noqa: E501
        """Get stats for a all peer instances of a local CRDB instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_peer_stats_get(bdb_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local CRDB instance. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_bdb_uid_peer_stats_get_with_http_info(bdb_uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_bdb_uid_peer_stats_get_with_http_info(bdb_uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_bdb_uid_peer_stats_get_with_http_info(self, bdb_uid, **kwargs):  # noqa: E501
        """Get stats for a all peer instances of a local CRDB instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_peer_stats_get_with_http_info(bdb_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local CRDB instance. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bdb_uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_bdb_uid_peer_stats_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bdb_uid' is set
        if ('bdb_uid' not in params or
                params['bdb_uid'] is None):
            raise ValueError("Missing the required parameter `bdb_uid` when calling `v1_bdbs_bdb_uid_peer_stats_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bdb_uid' in params:
            path_params['bdb_uid'] = params['bdb_uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(bdb_uid)/peer_stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_bdb_uid_peer_stats_intuid_get(self, bdb_uid, uid, **kwargs):  # noqa: E501
        """Get stats for a specific CRDB peer instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_peer_stats_intuid_get(bdb_uid, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local CRDB instance. (required)
        :param str uid: The peer instance uid, as specified in the CRDB instance list. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_bdb_uid_peer_stats_intuid_get_with_http_info(bdb_uid, uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_bdb_uid_peer_stats_intuid_get_with_http_info(bdb_uid, uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_bdb_uid_peer_stats_intuid_get_with_http_info(self, bdb_uid, uid, **kwargs):  # noqa: E501
        """Get stats for a specific CRDB peer instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_peer_stats_intuid_get_with_http_info(bdb_uid, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local CRDB instance. (required)
        :param str uid: The peer instance uid, as specified in the CRDB instance list. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bdb_uid', 'uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_bdb_uid_peer_stats_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bdb_uid' is set
        if ('bdb_uid' not in params or
                params['bdb_uid'] is None):
            raise ValueError("Missing the required parameter `bdb_uid` when calling `v1_bdbs_bdb_uid_peer_stats_intuid_get`")  # noqa: E501
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_bdb_uid_peer_stats_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bdb_uid' in params:
            path_params['bdb_uid'] = params['bdb_uid']  # noqa: E501
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(bdb_uid)/peer_stats/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_bdb_uid_sync_source_stats_get(self, bdb_uid, **kwargs):  # noqa: E501
        """Get stats for a all syncer sources of a local database.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_sync_source_stats_get(bdb_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local database. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_bdb_uid_sync_source_stats_get_with_http_info(bdb_uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_bdb_uid_sync_source_stats_get_with_http_info(bdb_uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_bdb_uid_sync_source_stats_get_with_http_info(self, bdb_uid, **kwargs):  # noqa: E501
        """Get stats for a all syncer sources of a local database.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_sync_source_stats_get_with_http_info(bdb_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local database. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bdb_uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_bdb_uid_sync_source_stats_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bdb_uid' is set
        if ('bdb_uid' not in params or
                params['bdb_uid'] is None):
            raise ValueError("Missing the required parameter `bdb_uid` when calling `v1_bdbs_bdb_uid_sync_source_stats_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bdb_uid' in params:
            path_params['bdb_uid'] = params['bdb_uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(bdb_uid)/sync_source_stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_bdb_uid_sync_source_stats_intuid_get(self, bdb_uid, uid, **kwargs):  # noqa: E501
        """Get stats for a specific syncer (replica-of) instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_sync_source_stats_intuid_get(bdb_uid, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local database. (required)
        :param str uid: The sync_source uid. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_bdb_uid_sync_source_stats_intuid_get_with_http_info(bdb_uid, uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_bdb_uid_sync_source_stats_intuid_get_with_http_info(bdb_uid, uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_bdb_uid_sync_source_stats_intuid_get_with_http_info(self, bdb_uid, uid, **kwargs):  # noqa: E501
        """Get stats for a specific syncer (replica-of) instance.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_bdb_uid_sync_source_stats_intuid_get_with_http_info(bdb_uid, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bdb_uid: The unique ID of the local database. (required)
        :param str uid: The sync_source uid. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bdb_uid', 'uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_bdb_uid_sync_source_stats_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bdb_uid' is set
        if ('bdb_uid' not in params or
                params['bdb_uid'] is None):
            raise ValueError("Missing the required parameter `bdb_uid` when calling `v1_bdbs_bdb_uid_sync_source_stats_intuid_get`")  # noqa: E501
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_bdb_uid_sync_source_stats_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bdb_uid' in params:
            path_params['bdb_uid'] = params['bdb_uid']  # noqa: E501
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(bdb_uid)/sync_source_stats/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_crdt_sources_alerts_get(self, **kwargs):  # noqa: E501
        """Get all alert states for all crdt sources of all CRDBs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each local BDB of CRDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_crdt_sources_alerts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_crdt_sources_alerts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_crdt_sources_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for all crdt sources of all CRDBs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each local BDB of CRDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_crdt_sources_alerts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/crdt_sources/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_crdt_sources_alerts_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get all alert states for all crdt source for specific local bdb of CRDB.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_crdt_sources_alerts_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_crdt_sources_alerts_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_crdt_sources_alerts_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get all alert states for all crdt source for specific local bdb of CRDB.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_crdt_sources_alerts_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_crdt_sources_alerts_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/crdt_sources/alerts/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get(self, uid, crdt_src_id, alert, **kwargs):  # noqa: E501
        """Get bdb alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get(uid, crdt_src_id, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str crdt_src_id: The ID of the crdt source in this BDB (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get_with_http_info(uid, crdt_src_id, alert, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get_with_http_info(uid, crdt_src_id, alert, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get_with_http_info(self, uid, crdt_src_id, alert, **kwargs):  # noqa: E501
        """Get bdb alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get_with_http_info(uid, crdt_src_id, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str crdt_src_id: The ID of the crdt source in this BDB (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'crdt_src_id', 'alert']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get`")  # noqa: E501
        # verify the required parameter 'crdt_src_id' is set
        if ('crdt_src_id' not in params or
                params['crdt_src_id'] is None):
            raise ValueError("Missing the required parameter `crdt_src_id` when calling `v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get`")  # noqa: E501
        # verify the required parameter 'alert' is set
        if ('alert' not in params or
                params['alert'] is None):
            raise ValueError("Missing the required parameter `alert` when calling `v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_alert_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'crdt_src_id' in params:
            path_params['crdt_src_id'] = params['crdt_src_id']  # noqa: E501
        if 'alert' in params:
            path_params['alert'] = params['alert']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/crdt_sources/alerts/(int:uid)/(int:crdt_src_id)/(alert)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get(self, uid, crdt_src_id, **kwargs):  # noqa: E501
        """Get all alert states for specific crdt source for specific local bdb of CRDB.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get(uid, crdt_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str crdt_src_id: The ID of the crdt source in this BDB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get_with_http_info(uid, crdt_src_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get_with_http_info(uid, crdt_src_id, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get_with_http_info(self, uid, crdt_src_id, **kwargs):  # noqa: E501
        """Get all alert states for specific crdt source for specific local bdb of CRDB.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get_with_http_info(uid, crdt_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str crdt_src_id: The ID of the crdt source in this BDB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'crdt_src_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get`")  # noqa: E501
        # verify the required parameter 'crdt_src_id' is set
        if ('crdt_src_id' not in params or
                params['crdt_src_id'] is None):
            raise ValueError("Missing the required parameter `crdt_src_id` when calling `v1_bdbs_crdt_sources_alerts_intuid_intcrdt_src_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'crdt_src_id' in params:
            path_params['crdt_src_id'] = params['crdt_src_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/crdt_sources/alerts/(int:uid)/(int:crdt_src_id)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_get(self, **kwargs):  # noqa: E501
        """Get all databases in the cluster.  # noqa: E501

        The response body contains a JSON array with all databases, represented as bdb objects.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields: Optional comma separated list of field names to return (by default all fields are returned).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all databases in the cluster.  # noqa: E501

        The response body contains a JSON array with all databases, represented as bdb objects.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields: Optional comma separated list of field names to return (by default all fields are returned).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_backup_reset_status_put(self, uid, **kwargs):  # noqa: E501
        """Reset database current backup status (backup_status) to idle if not in progress. As well clear exiting backup_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets backup_status to idle value and clear failure reason message if exist from backup_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_backup_reset_status_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_backup_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_backup_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_backup_reset_status_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Reset database current backup status (backup_status) to idle if not in progress. As well clear exiting backup_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets backup_status to idle value and clear failure reason message if exist from backup_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_backup_reset_status_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_backup_reset_status_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_backup_reset_status_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/backup_reset_status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_export_post(self, uid, **kwargs):  # noqa: E501
        """Initiate a database export.  # noqa: E501

        The request body should contain a JSON object, with the following export parameters:  backup_location field to retrieve the object’s structure.  email_notification - optional, when true an email on failure/completion will be sent when export is done.  See Backup Location for more details on the backup location types.  **Example request** :  **Example response** :  The above request initiates an export operation to the specified location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_export_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_export_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_export_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_export_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Initiate a database export.  # noqa: E501

        The request body should contain a JSON object, with the following export parameters:  backup_location field to retrieve the object’s structure.  email_notification - optional, when true an email on failure/completion will be sent when export is done.  See Backup Location for more details on the backup location types.  **Example request** :  **Example response** :  The above request initiates an export operation to the specified location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_export_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_export_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_export_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_export_reset_status_put(self, uid, **kwargs):  # noqa: E501
        """Reset database current export status (export_status) to idle if not in progress. As well clear exiting export_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets export_status to idle value and clear failure reason message if exist from export_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_export_reset_status_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_export_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_export_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_export_reset_status_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Reset database current export status (export_status) to idle if not in progress. As well clear exiting export_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets export_status to idle value and clear failure reason message if exist from export_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_export_reset_status_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_export_reset_status_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_export_reset_status_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/export_reset_status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_import_post(self, uid, **kwargs):  # noqa: E501
        """Initiate a manual import process.  # noqa: E501

        The request **may** contain a subset of the bdb JSON object, which includes the following import-related attributes:  dataset_import_sources field to retrieve the object’s structure.  email_notification - optional, when true an email on failure/completion will be sent when import is done.  See Import Sources for more details on the import location types.  Other attributes are not allowed and will fail the request.  **Example request** :  **Example response** :  The above request initiates an import process using dataset_import_sources values that were previously configured for the database.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_import_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_import_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_import_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_import_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Initiate a manual import process.  # noqa: E501

        The request **may** contain a subset of the bdb JSON object, which includes the following import-related attributes:  dataset_import_sources field to retrieve the object’s structure.  email_notification - optional, when true an email on failure/completion will be sent when import is done.  See Import Sources for more details on the import location types.  Other attributes are not allowed and will fail the request.  **Example request** :  **Example response** :  The above request initiates an import process using dataset_import_sources values that were previously configured for the database.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_import_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_import_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_import_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_import_reset_status_put(self, uid, **kwargs):  # noqa: E501
        """Reset database current import status (import_status) to idle if not in progress. As well clear exiting import_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets import_status to idle value if not in progress and clear failure reason message if exist from import_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_import_reset_status_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_import_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_import_reset_status_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_import_reset_status_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Reset database current import status (import_status) to idle if not in progress. As well clear exiting import_failure_reason if exits  # noqa: E501

        **Example request** :  **Example response** :  The above request resets import_status to idle value if not in progress and clear failure reason message if exist from import_failure_reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_import_reset_status_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_import_reset_status_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_import_reset_status_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/import_reset_status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_optimize_shards_placement_get(self, **kwargs):  # noqa: E501
        """Get optimized shards placement for the given database.  # noqa: E501

        **Example request** :  **Example response** :  The blueprint returned as the result of this call can be submitted via PUT to the database as the shards_blueprint field. This will cause the shards to be rearranged according to this blueprint. One should use the cluster-state-id feature when trying to optimize the shards placement using the plan returned by this api call. The cluster-state-id returned in the header of this api call, should be passed in the headers of the PUT request on the database, in order to make sure that the optimized shard placement is relevant for the current cluster state. The cluster will reject the update if its state was changed since the optimal shards placement was obtained.  **Example request for rearranging the shards of the database** :  Note that submitting such an optimized blueprint may cause strain on the cluster and its resources, and should therefore be used with caution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_optimize_shards_placement_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_optimize_shards_placement_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_optimize_shards_placement_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_optimize_shards_placement_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get optimized shards placement for the given database.  # noqa: E501

        **Example request** :  **Example response** :  The blueprint returned as the result of this call can be submitted via PUT to the database as the shards_blueprint field. This will cause the shards to be rearranged according to this blueprint. One should use the cluster-state-id feature when trying to optimize the shards placement using the plan returned by this api call. The cluster-state-id returned in the header of this api call, should be passed in the headers of the PUT request on the database, in order to make sure that the optimized shard placement is relevant for the current cluster state. The cluster will reject the update if its state was changed since the optimal shards placement was obtained.  **Example request for rearranging the shards of the database** :  Note that submitting such an optimized blueprint may cause strain on the cluster and its resources, and should therefore be used with caution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_optimize_shards_placement_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_optimize_shards_placement_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/optimize_shards_placement', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_recover_get(self, uid, **kwargs):  # noqa: E501
        """Fetch the recovery plan for a database. The recovery plan provides information about the recovery status (if it is possible) and specific detail on which available files to recovery from have been found.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_recover_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which recovery plan is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_recover_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_recover_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_recover_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Fetch the recovery plan for a database. The recovery plan provides information about the recovery status (if it is possible) and specific detail on which available files to recovery from have been found.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_recover_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which recovery plan is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_recover_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_recover_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/recover', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_actions_recover_post(self, uid, **kwargs):  # noqa: E501
        """Initiate recovery for a database in recovery state.  # noqa: E501

        The request body may be empty, in which case the database will be recovered automatically:  Databases with no persistence are recovered with no data.  Persistent files (aof, rdb) will be loaded from their expected storage locations (i.e. where slave or master shards were last active).  If persistent files are not found where expected but can be located on other cluster nodes, they will be used.  In addition, the request may include a request body with an explicit recovery plan.  **Example request, no recovery plan** :  **Example request, detailed recovery plan** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_recover_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to recover. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_actions_recover_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_actions_recover_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_actions_recover_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Initiate recovery for a database in recovery state.  # noqa: E501

        The request body may be empty, in which case the database will be recovered automatically:  Databases with no persistence are recovered with no data.  Persistent files (aof, rdb) will be loaded from their expected storage locations (i.e. where slave or master shards were last active).  If persistent files are not found where expected but can be located on other cluster nodes, they will be used.  In addition, the request may include a request body with an explicit recovery plan.  **Example request, no recovery plan** :  **Example request, detailed recovery plan** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_actions_recover_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to recover. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_actions_recover_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_actions_recover_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/actions/recover', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_anyaction_put(self, uid, action, **kwargs):  # noqa: E501
        """Update the configuration of an active database.  # noqa: E501

        If passed with the dry_run URL query string, the function will validate the bdb object against the existing bdb, but will not invoke the state machine that will update it.  **Example request** :  The above request attempts to modify a database configuration to enable in-memory data replication and Append-Only File data persistence.  *Note* : Changing the shard hashing policy requires flushing all keys from the database.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  rack_awareness_violation  Non rack aware cluster.  Not enough nodes in unique racks.  invalid_certificate  SSL client certificate is missing or malformed.  certificate_expired | SSL client certificate has expired.  duplicated_certs | An SSL client certificate appears more than once.  insufficient_resources  Shards count exceeds shards limit per bdb.  not_supported_action_on_crdt  reset_admin_pass action is not allowed on CRDT enabled BDB.  bad_shards_blueprint  The sharding blueprint is broken or doesn’t fit the BDB.  replication_violation  CRDT database must use replication.  eviction_policy_violation  LFU eviction policy is not supported on bdb version<4  replication_node_violation  Not enough nodes for replication.  replication_size_violation  Database limit too small for replication  invalid_oss_cluster_configuration  BDB configuration does not meet the requirements for oss cluster mode  missing_backup_interval  BDB backup is enabled but backup interval is missing.  crdt_sharding_violation  CRDB created without sharding cannot be changed to use sharding  invalid_proxy_policy  Invalid proxy_policy value.  invalid_bdb_tags  Tag objects with the same key parameter were passed  redis_acl_unsupported | Redis ACL is not supported for this database  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_anyaction_put(uid, action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which update is requested. (required)
        :param str action: Additional action to perform. Currently the supported actions are: flush , reset_admin_pass . (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_anyaction_put_with_http_info(uid, action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_anyaction_put_with_http_info(uid, action, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_anyaction_put_with_http_info(self, uid, action, **kwargs):  # noqa: E501
        """Update the configuration of an active database.  # noqa: E501

        If passed with the dry_run URL query string, the function will validate the bdb object against the existing bdb, but will not invoke the state machine that will update it.  **Example request** :  The above request attempts to modify a database configuration to enable in-memory data replication and Append-Only File data persistence.  *Note* : Changing the shard hashing policy requires flushing all keys from the database.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  rack_awareness_violation  Non rack aware cluster.  Not enough nodes in unique racks.  invalid_certificate  SSL client certificate is missing or malformed.  certificate_expired | SSL client certificate has expired.  duplicated_certs | An SSL client certificate appears more than once.  insufficient_resources  Shards count exceeds shards limit per bdb.  not_supported_action_on_crdt  reset_admin_pass action is not allowed on CRDT enabled BDB.  bad_shards_blueprint  The sharding blueprint is broken or doesn’t fit the BDB.  replication_violation  CRDT database must use replication.  eviction_policy_violation  LFU eviction policy is not supported on bdb version<4  replication_node_violation  Not enough nodes for replication.  replication_size_violation  Database limit too small for replication  invalid_oss_cluster_configuration  BDB configuration does not meet the requirements for oss cluster mode  missing_backup_interval  BDB backup is enabled but backup interval is missing.  crdt_sharding_violation  CRDB created without sharding cannot be changed to use sharding  invalid_proxy_policy  Invalid proxy_policy value.  invalid_bdb_tags  Tag objects with the same key parameter were passed  redis_acl_unsupported | Redis ACL is not supported for this database  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_anyaction_put_with_http_info(uid, action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which update is requested. (required)
        :param str action: Additional action to perform. Currently the supported actions are: flush , reset_admin_pass . (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_anyaction_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_anyaction_put`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_bdbs_intuid_anyaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/(any:action)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_command_post(self, uid, **kwargs):  # noqa: E501
        """Execute a redis/memcached command, per the db type.  # noqa: E501

        The request must contain a redis command JSON representation consists of a ‘command’ field. It may also consist of an ‘args’ array.  **1. Redis Example request** :  **Example response** :  **2. Redis Example request** :  **Example response** :  **2. Memcached Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_command_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The uid of the db on which the command will be performed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_command_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_command_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_command_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Execute a redis/memcached command, per the db type.  # noqa: E501

        The request must contain a redis command JSON representation consists of a ‘command’ field. It may also consist of an ‘args’ array.  **1. Redis Example request** :  **Example response** :  **2. Redis Example request** :  **Example response** :  **2. Memcached Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_command_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The uid of the db on which the command will be performed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_command_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete an active database.  # noqa: E501

        **Example request** :  The above request attempts to completely delete database with unique ID 1.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete an active database.  # noqa: E501

        **Example request** :  The above request attempts to completely delete database with unique ID 1.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get single database (bdb object) as json.  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional db parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The unique ID of the database requested. (required)
        :param str fields: Optional comma separated list of field names to return (by default all fields are returned).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get single database (bdb object) as json.  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional db parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float uid: The unique ID of the database requested. (required)
        :param str fields: Optional comma separated list of field names to return (by default all fields are returned).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_passwords_delete(self, uid, **kwargs):  # noqa: E501
        """Delete a password from the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request deletes a password from the bdb.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_passwords_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_passwords_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_passwords_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete a password from the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request deletes a password from the bdb.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_passwords_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_passwords_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/passwords', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_passwords_post(self, uid, **kwargs):  # noqa: E501
        """Add a password to the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request adds a password to the bdb.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_post(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_passwords_post_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_passwords_post_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_passwords_post_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Add a password to the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request adds a password to the bdb.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_post_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_passwords_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_passwords_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/passwords', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_passwords_put(self, uid, **kwargs):  # noqa: E501
        """Set a (single) password to the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request resets the password of the bdb to ‘new password’  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_passwords_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_passwords_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_passwords_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Set a (single) password to the bdb’s default user (i.e., for AUTH <password> authentications).  # noqa: E501

        **Example request** :  The above request resets the password of the bdb to ‘new password’  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_passwords_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database to which the password is to be added. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_passwords_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_passwords_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/passwords', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_put(self, uid, **kwargs):  # noqa: E501
        """Update the configuration of an active database.  This is the simplified version of the update request which contains no additional action.  # noqa: E501

        Tracking this request’s progress is done by polling the /actions/<action_uid> API with the action_uid returned by this API.  **Example request** :  The above request attempts to modify a database configuration to enable in-memory data replication and Append-Only File data persistence.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which update is requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Update the configuration of an active database.  This is the simplified version of the update request which contains no additional action.  # noqa: E501

        Tracking this request’s progress is done by polling the /actions/<action_uid> API with the action_uid returned by this API.  **Example request** :  The above request attempts to modify a database configuration to enable in-memory data replication and Append-Only File data persistence.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database for which update is requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_intuid_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_intuid_upgrade_post(self, **kwargs):  # noqa: E501
        """Upgrade a BDB  # noqa: E501

        **Example request** :  **Example response** :  The allowed parameters are: force_restart : restart shards even if no version change (default: false) keep_redis_version : keep current redis version (default: false) keep_crdt_protocol_version : keep current crdt protocol version (default: false) may_discard_data : discard data in a non-replicated non-persistent bdb (default: false) force_discard : discard data even if the bdb is replicated and/or persistent (default: false) preserve_roles : should preserve shards’ master/slave roles (requires and extra failover) (default: false) parallel_shards_upgrade : max number of many shards to upgrade in parallel (default: all) modules : list of dicts representing the modules that will be upgraded. Each dict will include: * current_module : uid of a module to upgrade * new_module : uid of the module we want to upgrade to * new_module_args : args list for the new module (no defaults for the three module-related parameters). redis_version : explicitly specify which redis version to upgrade to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_upgrade_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_intuid_upgrade_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_intuid_upgrade_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_intuid_upgrade_post_with_http_info(self, **kwargs):  # noqa: E501
        """Upgrade a BDB  # noqa: E501

        **Example request** :  **Example response** :  The allowed parameters are: force_restart : restart shards even if no version change (default: false) keep_redis_version : keep current redis version (default: false) keep_crdt_protocol_version : keep current crdt protocol version (default: false) may_discard_data : discard data in a non-replicated non-persistent bdb (default: false) force_discard : discard data even if the bdb is replicated and/or persistent (default: false) preserve_roles : should preserve shards’ master/slave roles (requires and extra failover) (default: false) parallel_shards_upgrade : max number of many shards to upgrade in parallel (default: all) modules : list of dicts representing the modules that will be upgraded. Each dict will include: * current_module : uid of a module to upgrade * new_module : uid of the module we want to upgrade to * new_module_args : args list for the new module (no defaults for the three module-related parameters). redis_version : explicitly specify which redis version to upgrade to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_intuid_upgrade_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_intuid_upgrade_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(int:uid)/upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_post(self, **kwargs):  # noqa: E501
        """Create a new database in the cluster.  # noqa: E501

        The request must contain a single JSON bdb object with the configuration parameters for the new database.  If passed with the dry_run URL query string, the function will validate the bdb object, but will not invoke the state machine that will create it.  Tracking this request’s progress is done by polling the /actions/<action_uid> API with the action_uid returned by this API.  The cluster will use default configuration for any missing bdb field. The database uid will be created by the cluster if it is missing.  The response includes the newly created bdb object.  **Example request** :  **Example response** :  The above request is an attempt to create a Redis database with a user- specified name and a memory limit of 1GB.  The uid of the database is auto-assigned by the cluster because it was not explicitly listed in the request. If you specify the database ID (uid) then you must specify the database ID for every subsequent database and you must make sure that the database ID does not conflict with an existing database. If you do not specify the database ID, then the database ID is automatically assigned in sequential order.  Defaults are used for all other configuration parameters.  See Object Attributes for more details on additional db parameters  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  uid_exists  The specified database UID is already in use.  missing_db_name  DB name is a required property.  missing_memory_size  Memory Size is a required property.  missing_module  Modules missing from the cluster  port_unavailable  The specified database port is reserved or already in use.  invalid_sharding  Invalid sharding configuration was specified.  bad_shards_blueprint  The sharding blueprint is broken.  not_rack_aware  Cluster is not rack aware and a rack aware database was requested.  invalid_version  An invalid database version was requested.  busy  The request failed because another request is being processed at the same time on the same database.  invalid_data_persistence  Invalid data persistence configuration.  invalid_proxy_policy  Invalid proxy_policy value.  invalid_sasl_credentials  SASL credentials are missing or invalid.  invalid_replication  Not enough nodes to perform replication.  insufficient_resources  Not enough resources in cluster to host the database.  rack_awareness_violation  Rack awareness violation.  Not enough nodes in unique racks.  invalid_certificate  SSL client certificate is missing or malformed.  certificate_expired  SSL client certificate has expired.  duplicated_certs  An SSL client certificate appears more than once.  replication_violation  CRDT database must use replication.  eviction_policy_violation  LFU eviction policy is not supported on bdb version<4  invalid_oss_cluster_configuration  BDB configuration does not meet the requirements for oss cluster mode  memcached_cannot_use_modules  Cannot create a memcached database with modules  missing_backup_interval  BDB backup is enabled but backup interval is missing.  wrong_cluster_state_id  The given CLUSTER-STATE-ID does not match the current one  invalid_bdb_tags  Tag objects with the same key parameter were passed.  unsupported_module_capabilities  Not all modules configured for the database support the capabilities needed for the database configuration  redis_acl_unsupported  Redis ACL is not supported for this database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new database in the cluster.  # noqa: E501

        The request must contain a single JSON bdb object with the configuration parameters for the new database.  If passed with the dry_run URL query string, the function will validate the bdb object, but will not invoke the state machine that will create it.  Tracking this request’s progress is done by polling the /actions/<action_uid> API with the action_uid returned by this API.  The cluster will use default configuration for any missing bdb field. The database uid will be created by the cluster if it is missing.  The response includes the newly created bdb object.  **Example request** :  **Example response** :  The above request is an attempt to create a Redis database with a user- specified name and a memory limit of 1GB.  The uid of the database is auto-assigned by the cluster because it was not explicitly listed in the request. If you specify the database ID (uid) then you must specify the database ID for every subsequent database and you must make sure that the database ID does not conflict with an existing database. If you do not specify the database ID, then the database ID is automatically assigned in sequential order.  Defaults are used for all other configuration parameters.  See Object Attributes for more details on additional db parameters  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  uid_exists  The specified database UID is already in use.  missing_db_name  DB name is a required property.  missing_memory_size  Memory Size is a required property.  missing_module  Modules missing from the cluster  port_unavailable  The specified database port is reserved or already in use.  invalid_sharding  Invalid sharding configuration was specified.  bad_shards_blueprint  The sharding blueprint is broken.  not_rack_aware  Cluster is not rack aware and a rack aware database was requested.  invalid_version  An invalid database version was requested.  busy  The request failed because another request is being processed at the same time on the same database.  invalid_data_persistence  Invalid data persistence configuration.  invalid_proxy_policy  Invalid proxy_policy value.  invalid_sasl_credentials  SASL credentials are missing or invalid.  invalid_replication  Not enough nodes to perform replication.  insufficient_resources  Not enough resources in cluster to host the database.  rack_awareness_violation  Rack awareness violation.  Not enough nodes in unique racks.  invalid_certificate  SSL client certificate is missing or malformed.  certificate_expired  SSL client certificate has expired.  duplicated_certs  An SSL client certificate appears more than once.  replication_violation  CRDT database must use replication.  eviction_policy_violation  LFU eviction policy is not supported on bdb version<4  invalid_oss_cluster_configuration  BDB configuration does not meet the requirements for oss cluster mode  memcached_cannot_use_modules  Cannot create a memcached database with modules  missing_backup_interval  BDB backup is enabled but backup interval is missing.  wrong_cluster_state_id  The given CLUSTER-STATE-ID does not match the current one  invalid_bdb_tags  Tag objects with the same key parameter were passed.  unsupported_module_capabilities  Not all modules configured for the database support the capabilities needed for the database configuration  redis_acl_unsupported  Redis ACL is not supported for this database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_replica_sources_alerts_get(self, **kwargs):  # noqa: E501
        """Get all alert states for all replica sources of all BDBs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each BDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_replica_sources_alerts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_replica_sources_alerts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_replica_sources_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for all replica sources of all BDBs.  # noqa: E501

        Returns a hash of alert uid’s and the alerts states for each BDB.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_replica_sources_alerts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/replica_sources/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_replica_sources_alerts_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get all alert states for all replica source of specific bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_replica_sources_alerts_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_replica_sources_alerts_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_replica_sources_alerts_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get all alert states for all replica source of specific bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_replica_sources_alerts_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_replica_sources_alerts_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/replica_sources/alerts/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get(self, uid, replica_src_id, alert, **kwargs):  # noqa: E501
        """Get replica source alert state of specific bdb.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get(uid, replica_src_id, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str replica_src_id: The ID of the replica source in this BDB (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get_with_http_info(uid, replica_src_id, alert, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get_with_http_info(uid, replica_src_id, alert, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get_with_http_info(self, uid, replica_src_id, alert, **kwargs):  # noqa: E501
        """Get replica source alert state of specific bdb.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get_with_http_info(uid, replica_src_id, alert, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str replica_src_id: The ID of the replica source in this BDB (required)
        :param str alert: The alert name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'replica_src_id', 'alert']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get`")  # noqa: E501
        # verify the required parameter 'replica_src_id' is set
        if ('replica_src_id' not in params or
                params['replica_src_id'] is None):
            raise ValueError("Missing the required parameter `replica_src_id` when calling `v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get`")  # noqa: E501
        # verify the required parameter 'alert' is set
        if ('alert' not in params or
                params['alert'] is None):
            raise ValueError("Missing the required parameter `alert` when calling `v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_alert_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'replica_src_id' in params:
            path_params['replica_src_id'] = params['replica_src_id']  # noqa: E501
        if 'alert' in params:
            path_params['alert'] = params['alert']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/replica_sources/alerts/(int:uid)/(int:replica_src_id)/(alert)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get(self, uid, replica_src_id, **kwargs):  # noqa: E501
        """Get all alert states for specific replica source of bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get(uid, replica_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str replica_src_id: The ID of the replica source in this BDB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get_with_http_info(uid, replica_src_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get_with_http_info(uid, replica_src_id, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get_with_http_info(self, uid, replica_src_id, **kwargs):  # noqa: E501
        """Get all alert states for specific replica source of bdb.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get_with_http_info(uid, replica_src_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the database (required)
        :param str replica_src_id: The ID of the replica source in this BDB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'replica_src_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get`")  # noqa: E501
        # verify the required parameter 'replica_src_id' is set
        if ('replica_src_id' not in params or
                params['replica_src_id'] is None):
            raise ValueError("Missing the required parameter `replica_src_id` when calling `v1_bdbs_replica_sources_alerts_intuid_intreplica_src_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501
        if 'replica_src_id' in params:
            path_params['replica_src_id'] = params['replica_src_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/replica_sources/alerts/(int:uid)/(int:replica_src_id)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stats_get(self, **kwargs):  # noqa: E501
        """Get stats for all BDBs.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stats_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stats_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_stats_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get stats for all BDBs.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stats_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get stats for BDB.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the BDB requested. (required)
        :param str interval: Optional time interval for for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_stats_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get stats for BDB.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the BDB requested. (required)
        :param str interval: Optional time interval for for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stats_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_stats_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/stats/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stats_last_get(self, **kwargs):  # noqa: E501
        """Get the most recent statistic information for all BDBs.  # noqa: E501

        **1. Example request** :  **Example response** :  **2. Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_last_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stats_last_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stats_last_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_stats_last_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the most recent statistic information for all BDBs.  # noqa: E501

        **1. Example request** :  **Example response** :  **2. Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_last_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['metrics']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stats_last_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'metrics' in params:
            query_params.append(('metrics', params['metrics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/stats/last', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stats_last_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get the most recent statistic information for BDB.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_last_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the requested BDB. (required)
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_bdbs_stats_last_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get the most recent statistic information for BDB.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stats_last_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the requested BDB. (required)
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'metrics']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stats_last_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_bdbs_stats_last_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'metrics' in params:
            query_params.append(('metrics', params['metrics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/stats/last/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stringuid_modules_config_post(self, **kwargs):  # noqa: E501
        """v1_bdbs_stringuid_modules_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stringuid_modules_config_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stringuid_modules_config_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stringuid_modules_config_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_stringuid_modules_config_post_with_http_info(self, **kwargs):  # noqa: E501
        """v1_bdbs_stringuid_modules_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stringuid_modules_config_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stringuid_modules_config_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(string:uid)/modules/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bdbs_stringuid_modules_upgrade_post(self, **kwargs):  # noqa: E501
        """v1_bdbs_stringuid_modules_upgrade_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stringuid_modules_upgrade_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bdbs_stringuid_modules_upgrade_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bdbs_stringuid_modules_upgrade_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bdbs_stringuid_modules_upgrade_post_with_http_info(self, **kwargs):  # noqa: E501
        """v1_bdbs_stringuid_modules_upgrade_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bdbs_stringuid_modules_upgrade_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bdbs_stringuid_modules_upgrade_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bdbs/(string:uid)/modules/upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bootstrap_action_post(self, **kwargs):  # noqa: E501
        """Initiate bootstrapping.  # noqa: E501

        The request must contain a bootstrap configuration JSON object, as described in `node.Bootstrap` or a minimal subset.  Bootstrapping is permitted only when the current bootstrap state is idle or error (in which case the process will restart with the new configuration).  This request is asynchronous - once the request has been accepted, the caller is expected to poll bootstrap status waiting for it to complete  **1. Example request- Join Cluster** :  **2. Example request- Create Cluster** :  See Object Attributes for more details on the Bootstrap object properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_action_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bootstrap_action_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bootstrap_action_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bootstrap_action_post_with_http_info(self, **kwargs):  # noqa: E501
        """Initiate bootstrapping.  # noqa: E501

        The request must contain a bootstrap configuration JSON object, as described in `node.Bootstrap` or a minimal subset.  Bootstrapping is permitted only when the current bootstrap state is idle or error (in which case the process will restart with the new configuration).  This request is asynchronous - once the request has been accepted, the caller is expected to poll bootstrap status waiting for it to complete  **1. Example request- Join Cluster** :  **2. Example request- Create Cluster** :  See Object Attributes for more details on the Bootstrap object properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_action_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bootstrap_action_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bootstrap/(action)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bootstrap_get(self, **kwargs):  # noqa: E501
        """Get the local node’s bootstrap status.  # noqa: E501

        This request is accepted as soon the cluster software is installed, and before the node is part of an active cluster.  Once the node is part of an active cluster authentication is required.  The JSON response object contains two other objects: bootstrap_status which is described below, and local_node_info which is a subset of a node object that provides information about the node configuration.  The bootstrap_status object contains the following fields:  Field  Description  state  Current bootstrap state.  idle : No bootstrapping started.  initiated : Bootstrap request received.  creating_cluster : In the process of creating a new cluster.  joining_cluster : In the process of joining an existing cluster.  error : The last bootstrap action failed.  completed : The last bootstrap action completed successfully.  start_time  Bootstrap process start time  end_time  Bootstrap process end time  error_code  If state is error , this is an error code that describes the type of error encountered.  config_error : An error related to the bootstrap configuration provided (e.g. bad JSON).  connect_error : Failed to connect to cluster (e.g. FQDN DNS could not resolve, no/wrong node IP provided, etc.  access_denied : Invalid credentials supplied.  invalid_license : The license string provided is invalid. Additional info can be fetched from the error_details object, which includes the violation code in case the license is valid but it terms are violated.  repair_required : Cluster is in degraded mode and can only accept replacement nodes. When this happens, error_details contains two fields: failed_nodes and ‘replace_candidate’. The failed_nodes field is an array of objects, each describing a failed node with at least a uid field and an optional rack_id . replace_candidate is the uid of the node most suitable for replacement.  ‘insufficient_node_memory’: An attempt to replace a dead node fails because the replaced node does not have enough memory. When this happens, error_details contains a required_memory field which indicates the node memory requirement.  ‘insufficient_node_flash’: An attempt to replace a dead node fails because the replaced node does not have enough flash. When this happens, error_details contains a required_flash field which indicates the node flash requirement.  ‘time_not_sync’: An attempt to join a node with system time not synchronized with the rest of the cluster.  ‘rack_id_required’: An attempt to join a node with no rack_id in a rack-aware cluster. In addition, a ‘current_rack_ids’ field will include an array of currently used rack ids.  ‘socket_directory_mismatch’: An attempt to join a node with a socket directory setting that differs from the cluster  ‘node_config_mismatch’: An attempt to join a node with a configuration setting (e.g. confdir, osuser, installdir) that differs from the cluster  path_error : A needed path does not exist or is not accessable.  internal_error : A different, unspecified internal error was encountered.  error_details  An error-specific object that may contain additional information about the error. A common field in use is message which provides a more verbose error message.  **Example request**  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bootstrap_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bootstrap_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bootstrap_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the local node’s bootstrap status.  # noqa: E501

        This request is accepted as soon the cluster software is installed, and before the node is part of an active cluster.  Once the node is part of an active cluster authentication is required.  The JSON response object contains two other objects: bootstrap_status which is described below, and local_node_info which is a subset of a node object that provides information about the node configuration.  The bootstrap_status object contains the following fields:  Field  Description  state  Current bootstrap state.  idle : No bootstrapping started.  initiated : Bootstrap request received.  creating_cluster : In the process of creating a new cluster.  joining_cluster : In the process of joining an existing cluster.  error : The last bootstrap action failed.  completed : The last bootstrap action completed successfully.  start_time  Bootstrap process start time  end_time  Bootstrap process end time  error_code  If state is error , this is an error code that describes the type of error encountered.  config_error : An error related to the bootstrap configuration provided (e.g. bad JSON).  connect_error : Failed to connect to cluster (e.g. FQDN DNS could not resolve, no/wrong node IP provided, etc.  access_denied : Invalid credentials supplied.  invalid_license : The license string provided is invalid. Additional info can be fetched from the error_details object, which includes the violation code in case the license is valid but it terms are violated.  repair_required : Cluster is in degraded mode and can only accept replacement nodes. When this happens, error_details contains two fields: failed_nodes and ‘replace_candidate’. The failed_nodes field is an array of objects, each describing a failed node with at least a uid field and an optional rack_id . replace_candidate is the uid of the node most suitable for replacement.  ‘insufficient_node_memory’: An attempt to replace a dead node fails because the replaced node does not have enough memory. When this happens, error_details contains a required_memory field which indicates the node memory requirement.  ‘insufficient_node_flash’: An attempt to replace a dead node fails because the replaced node does not have enough flash. When this happens, error_details contains a required_flash field which indicates the node flash requirement.  ‘time_not_sync’: An attempt to join a node with system time not synchronized with the rest of the cluster.  ‘rack_id_required’: An attempt to join a node with no rack_id in a rack-aware cluster. In addition, a ‘current_rack_ids’ field will include an array of currently used rack ids.  ‘socket_directory_mismatch’: An attempt to join a node with a socket directory setting that differs from the cluster  ‘node_config_mismatch’: An attempt to join a node with a configuration setting (e.g. confdir, osuser, installdir) that differs from the cluster  path_error : A needed path does not exist or is not accessable.  internal_error : A different, unspecified internal error was encountered.  error_details  An error-specific object that may contain additional information about the error. A common field in use is message which provides a more verbose error message.  **Example request**  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bootstrap_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bootstrap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_bootstrap_validate_action_post(self, **kwargs):  # noqa: E501
        """Perform bootstrap validation.  # noqa: E501

        The request must contain a bootstrap configuration JSON object similar to the one used for actual bootstrapping.  Unlike actual bootstrapping, this request blocks and immediately returns with a response.  When an error is encountered, a bootstrap status JSON object is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_validate_action_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_bootstrap_validate_action_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_bootstrap_validate_action_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_bootstrap_validate_action_post_with_http_info(self, **kwargs):  # noqa: E501
        """Perform bootstrap validation.  # noqa: E501

        The request must contain a bootstrap configuration JSON object similar to the one used for actual bootstrapping.  Unlike actual bootstrapping, this request blocks and immediately returns with a response.  When an error is encountered, a bootstrap status JSON object is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_bootstrap_validate_action_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_bootstrap_validate_action_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bootstrap/validate/(action)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_actions_action_delete(self, action, **kwargs):  # noqa: E501
        """Cancel a queued or executing cluster action, or remove the status of a previously executed and completed action.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_delete(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action to cancel, currently no actions are supported. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_actions_action_delete_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_actions_action_delete_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_cluster_actions_action_delete_with_http_info(self, action, **kwargs):  # noqa: E501
        """Cancel a queued or executing cluster action, or remove the status of a previously executed and completed action.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_delete_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action to cancel, currently no actions are supported. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_actions_action_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_cluster_actions_action_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/actions/(action)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_actions_action_get(self, **kwargs):  # noqa: E501
        """v1_cluster_actions_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_actions_action_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_actions_action_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_actions_action_get_with_http_info(self, **kwargs):  # noqa: E501
        """v1_cluster_actions_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_actions_action_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/actions/(action)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_actions_action_post(self, action, **kwargs):  # noqa: E501
        """Initiate a cluster-wide action.  # noqa: E501

        The API allows only a single instance of any action type to be invoked at the same time, and violations of this requirement will result with a 409 CONFLICT response.  The caller is expected to query and process the results of the previously executed instance of the same action, which will be removed as soon as the new one is submitted.  The body content may provide additional action details. Currently it is not used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_post(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_actions_action_post_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_actions_action_post_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_cluster_actions_action_post_with_http_info(self, action, **kwargs):  # noqa: E501
        """Initiate a cluster-wide action.  # noqa: E501

        The API allows only a single instance of any action type to be invoked at the same time, and violations of this requirement will result with a 409 CONFLICT response.  The caller is expected to query and process the results of the previously executed instance of the same action, which will be removed as soon as the new one is submitted.  The body content may provide additional action details. Currently it is not used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_action_post_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_actions_action_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_cluster_actions_action_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/actions/(action)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_actions_get(self, action, **kwargs):  # noqa: E501
        """Get the status of a currently executing, queued or completed cluster action.  # noqa: E501

        If no action is specified, a JSON array of actions is returned, contained in an object such as this:  The response body for the action is a JSON object, as described in REST API actions overview .  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_get(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The action to check. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_actions_get_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_actions_get_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_cluster_actions_get_with_http_info(self, action, **kwargs):  # noqa: E501
        """Get the status of a currently executing, queued or completed cluster action.  # noqa: E501

        If no action is specified, a JSON array of actions is returned, contained in an object such as this:  The response body for the action is a JSON object, as described in REST API actions overview .  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_actions_get_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The action to check. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_actions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_cluster_actions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_alerts_alert_get(self, **kwargs):  # noqa: E501
        """Get cluster alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_alerts_alert_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_alerts_alert_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_alerts_alert_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_alerts_alert_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_alerts_alert_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignore_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_alerts_alert_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignore_settings' in params:
            query_params.append(('ignore_settings', params['ignore_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/alerts/(alert)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_alerts_get(self, **kwargs):  # noqa: E501
        """Get all alert states for the cluster object.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_alerts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_alerts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for the cluster object.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignore_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_alerts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignore_settings' in params:
            query_params.append(('ignore_settings', params['ignore_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_auditing_db_conns_delete(self, **kwargs):  # noqa: E501
        """Delete the Database Connections Auditing configurations.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +————————————————+————————————————————-+ | Code | Description | +================================================+=============================================================+ | db_conns_audit_config_not_found | Unable to find the Auditing configurations | +————————————————+————————————————————-+ | cannot_delete_audit_config_when_policy_enabled | Auditing Cluster policy is ‘enabled’ when trying to delete | | | the auditing configurations | +————————————————+————————————————————-+ | cannot_delete_audit_config_when_bdb_enabled | One of the BDBs has Auditing configuration ‘enabled’ when | | | trying to delete the auditing configurations | +————————————————+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_auditing_db_conns_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_auditing_db_conns_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_auditing_db_conns_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete the Database Connections Auditing configurations.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +————————————————+————————————————————-+ | Code | Description | +================================================+=============================================================+ | db_conns_audit_config_not_found | Unable to find the Auditing configurations | +————————————————+————————————————————-+ | cannot_delete_audit_config_when_policy_enabled | Auditing Cluster policy is ‘enabled’ when trying to delete | | | the auditing configurations | +————————————————+————————————————————-+ | cannot_delete_audit_config_when_bdb_enabled | One of the BDBs has Auditing configuration ‘enabled’ when | | | trying to delete the auditing configurations | +————————————————+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_auditing_db_conns_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/auditing/db_conns', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_auditing_db_conns_get(self, **kwargs):  # noqa: E501
        """Get the Database Connections Auditing configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————————-+————————————————————-+ | Code | Description | +==============================================+=============================================================+ | db_conns_auditing_unsupported_by_capability | Not all nodes support DB Connections Auditing capability | +———————————————-+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_auditing_db_conns_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_auditing_db_conns_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_auditing_db_conns_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the Database Connections Auditing configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————————-+————————————————————-+ | Code | Description | +==============================================+=============================================================+ | db_conns_auditing_unsupported_by_capability | Not all nodes support DB Connections Auditing capability | +———————————————-+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_auditing_db_conns_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/auditing/db_conns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_auditing_db_conns_put(self, **kwargs):  # noqa: E501
        """Update the Database Connections Auditing configurations.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————————-+————————————————————-+ | Code | Description | +==============================================+=============================================================+ | db_conns_auditing_unsupported_by_capability | Not all nodes support DB Connections Auditing capability | +———————————————-+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_auditing_db_conns_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_auditing_db_conns_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_auditing_db_conns_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update the Database Connections Auditing configurations.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————————-+————————————————————-+ | Code | Description | +==============================================+=============================================================+ | db_conns_auditing_unsupported_by_capability | Not all nodes support DB Connections Auditing capability | +———————————————-+————————————————————-+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_auditing_db_conns_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_auditing_db_conns_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/auditing/db_conns', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_certificates_get(self, **kwargs):  # noqa: E501
        """Get the clusters certificates.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_certificates_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_certificates_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_certificates_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the clusters certificates.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_certificates_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/certificates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_certificates_rotate_post(self, **kwargs):  # noqa: E501
        """Regenerates all internal cluster certificates. the certificate rotation will be performed on all nodes within the cluster. If “name” is provided, rotate only the specified certificate on all nodes within the cluster.  # noqa: E501

        We respond with 200 OK if we’ve managed to rotate the internal certificate(s) across the entire cluster  **Example request** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_rotate_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_certificates_rotate_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_certificates_rotate_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_certificates_rotate_post_with_http_info(self, **kwargs):  # noqa: E501
        """Regenerates all internal cluster certificates. the certificate rotation will be performed on all nodes within the cluster. If “name” is provided, rotate only the specified certificate on all nodes within the cluster.  # noqa: E501

        We respond with 200 OK if we’ve managed to rotate the internal certificate(s) across the entire cluster  **Example request** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_rotate_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_certificates_rotate_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/certificates/rotate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_certificates_stringcertificate_name_delete(self, **kwargs):  # noqa: E501
        """Removes specified cluster certificate both from CCS and from disk across all nodes. Only optional certificates can be deleted through this endpoint.  # noqa: E501

        **Example request** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_stringcertificate_name_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_certificates_stringcertificate_name_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_certificates_stringcertificate_name_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_certificates_stringcertificate_name_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Removes specified cluster certificate both from CCS and from disk across all nodes. Only optional certificates can be deleted through this endpoint.  # noqa: E501

        **Example request** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_certificates_stringcertificate_name_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_certificates_stringcertificate_name_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/certificates/(string:certificate_name)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_fs_wd_config_get(self, **kwargs):  # noqa: E501
        """Get cluster-wide fs wd config.  # noqa: E501

        Returns JSON object with the following fields: fs_wd_functionality, fs_wd_alert_mode  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_config_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_fs_wd_config_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_fs_wd_config_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_fs_wd_config_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster-wide fs wd config.  # noqa: E501

        Returns JSON object with the following fields: fs_wd_functionality, fs_wd_alert_mode  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_config_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_fs_wd_config_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/fs_wd/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_fs_wd_config_put(self, **kwargs):  # noqa: E501
        """Set cluster-wide fs wd config.  # noqa: E501

        Returns JSON object with the following fields: fs_wd_functionality, fs_wd_alert_mode  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_config_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_fs_wd_config_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_fs_wd_config_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_fs_wd_config_put_with_http_info(self, **kwargs):  # noqa: E501
        """Set cluster-wide fs wd config.  # noqa: E501

        Returns JSON object with the following fields: fs_wd_functionality, fs_wd_alert_mode  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_config_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_fs_wd_config_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/fs_wd/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_fs_wd_fs_path_config_get(self, **kwargs):  # noqa: E501
        """Get fs wd path config for cluster.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_fs_path_config_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_fs_wd_fs_path_config_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_fs_wd_fs_path_config_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_fs_wd_fs_path_config_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get fs wd path config for cluster.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_fs_path_config_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_fs_wd_fs_path_config_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/fs_wd/(fs_path)/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_fs_wd_fs_path_config_put(self, **kwargs):  # noqa: E501
        """Set fs wd path config for cluster.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_fs_path_config_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_fs_wd_fs_path_config_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_fs_wd_fs_path_config_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_fs_wd_fs_path_config_put_with_http_info(self, **kwargs):  # noqa: E501
        """Set fs wd path config for cluster.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_fs_wd_fs_path_config_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_fs_wd_fs_path_config_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/fs_wd/(fs_path)/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_get(self, **kwargs):  # noqa: E501
        """Get cluster info.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster info.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_ldap_delete(self, **kwargs):  # noqa: E501
        """Clear the LDAP configuration.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_ldap_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_ldap_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_ldap_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Clear the LDAP configuration.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_ldap_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/ldap', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_ldap_get(self, **kwargs):  # noqa: E501
        """Get the LDAP configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_ldap_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_ldap_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_ldap_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the LDAP configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_ldap_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/ldap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_ldap_put(self, **kwargs):  # noqa: E501
        """Set or update cluster LDAP configuration.  # noqa: E501

        **Example request** :  Possible ` error_code`s:  Code  Description  illegal_fields_combination  An unacceptable combination of fields was specified for the configuration object (e.g.: two mutually-exclusive fields), or a required field is missing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_ldap_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_ldap_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_ldap_put_with_http_info(self, **kwargs):  # noqa: E501
        """Set or update cluster LDAP configuration.  # noqa: E501

        **Example request** :  Possible ` error_code`s:  Code  Description  illegal_fields_combination  An unacceptable combination of fields was specified for the configuration object (e.g.: two mutually-exclusive fields), or a required field is missing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_ldap_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_ldap_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/ldap', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_module_capabilities_get(self, **kwargs):  # noqa: E501
        """List possible redis module capabilities Example request:  # noqa: E501

        **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_module_capabilities_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_module_capabilities_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_module_capabilities_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_module_capabilities_get_with_http_info(self, **kwargs):  # noqa: E501
        """List possible redis module capabilities Example request:  # noqa: E501

        **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_module_capabilities_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_module_capabilities_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/module-capabilities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_put(self, **kwargs):  # noqa: E501
        """Update cluster settings.  # noqa: E501

        If passed with the dry_run URL query string, the function will validate the cluster object, but will not apply the requested changes.  **Example request** :  The above request will enable email alerts and alert reporting for node failures and node removals.  Note that crdt_rest_client_timeout is in seconds.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  bad_conf  Designated port is already bound.  bad_debuginfo_path  Debuginfo path doesn’t exist.  Debuginfo path is inaccessible.  config_edit_conflict  Cluster config was edited by another source simultaneously.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update cluster settings.  # noqa: E501

        If passed with the dry_run URL query string, the function will validate the cluster object, but will not apply the requested changes.  **Example request** :  The above request will enable email alerts and alert reporting for node failures and node removals.  Note that crdt_rest_client_timeout is in seconds.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  bad_conf  Designated port is already bound.  bad_debuginfo_path  Debuginfo path doesn’t exist.  Debuginfo path is inaccessible.  config_edit_conflict  Cluster config was edited by another source simultaneously.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_services_configuration_get(self, **kwargs):  # noqa: E501
        """Get cluster services settings.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_services_configuration_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_services_configuration_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_services_configuration_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_services_configuration_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster services settings.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_services_configuration_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_services_configuration_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/services_configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_services_configuration_put(self, **kwargs):  # noqa: E501
        """Update the cluster services settings.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_services_configuration_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_services_configuration_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_services_configuration_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_services_configuration_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update the cluster services settings.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_services_configuration_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_services_configuration_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/services_configuration', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_stats_get(self, **kwargs):  # noqa: E501
        """Get cluster stats.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_stats_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_stats_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_stats_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_stats_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster stats.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_stats_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_stats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_stats_last_get(self, **kwargs):  # noqa: E501
        """Get the last cluster stat.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_stats_last_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_stats_last_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_stats_last_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_stats_last_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the last cluster stat.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_stats_last_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_stats_last_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/stats/last', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_cluster_update_cert_put(self, **kwargs):  # noqa: E501
        """Replaces specified cluster certificate with given one, the new certificate will be replaced on all nodes within the cluster. This end point will make sure given certificate is valid before actually updating the cluster.  # noqa: E501

        We respond with 200 OK if we’ve managed to replace certificate across the entire cluster 403/4 otherwise, it is highly recommended to retry updating the certificate in case of a failure as the cluster might be in undesired state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_update_cert_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_cluster_update_cert_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_cluster_update_cert_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_cluster_update_cert_put_with_http_info(self, **kwargs):  # noqa: E501
        """Replaces specified cluster certificate with given one, the new certificate will be replaced on all nodes within the cluster. This end point will make sure given certificate is valid before actually updating the cluster.  # noqa: E501

        We respond with 200 OK if we’ve managed to replace certificate across the entire cluster 403/4 otherwise, it is highly recommended to retry updating the certificate in case of a failure as the cluster might be in undesired state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_cluster_update_cert_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_cluster_update_cert_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/cluster/update_cert', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_debuginfo_all_bdb_intbdb_uid_get(self, **kwargs):  # noqa: E501
        """Fetch debuginfo from all nodes that are relevent to given bdb uid.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_all_bdb_intbdb_uid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_debuginfo_all_bdb_intbdb_uid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_debuginfo_all_bdb_intbdb_uid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_debuginfo_all_bdb_intbdb_uid_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch debuginfo from all nodes that are relevent to given bdb uid.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_all_bdb_intbdb_uid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_debuginfo_all_bdb_intbdb_uid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/debuginfo/all/bdb/(int:bdb_uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_debuginfo_all_get(self, **kwargs):  # noqa: E501
        """Fetch debuginfo from all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_all_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_debuginfo_all_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_debuginfo_all_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_debuginfo_all_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch debuginfo from all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_all_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_debuginfo_all_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/debuginfo/all', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_debuginfo_node_bdb_intbdb_uid_get(self, **kwargs):  # noqa: E501
        """Fetch debuginfo tarfile which contains logs and other system information used for troubleshooting, for the given bdb.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_node_bdb_intbdb_uid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_debuginfo_node_bdb_intbdb_uid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_debuginfo_node_bdb_intbdb_uid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_debuginfo_node_bdb_intbdb_uid_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch debuginfo tarfile which contains logs and other system information used for troubleshooting, for the given bdb.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_node_bdb_intbdb_uid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_debuginfo_node_bdb_intbdb_uid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/debuginfo/node/bdb/(int:bdb_uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_debuginfo_node_get(self, **kwargs):  # noqa: E501
        """Fetch debuginfo tarfile which contains logs and other system information used for troubleshooting.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_node_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_debuginfo_node_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_debuginfo_node_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_debuginfo_node_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch debuginfo tarfile which contains logs and other system information used for troubleshooting.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_debuginfo_node_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_debuginfo_node_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/debuginfo/node', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_endpoints_stats_get(self, **kwargs):  # noqa: E501
        """Get stats for all endpoint-proxy links. Note: this method will return both endpoints and listeners stats for backwards compatability.  # noqa: E501

        for example: “1:2:3” is BDB_uid=1, ENDPOINT_UID=2, PROXY_UID=3  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_endpoints_stats_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_endpoints_stats_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_endpoints_stats_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_endpoints_stats_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get stats for all endpoint-proxy links. Note: this method will return both endpoints and listeners stats for backwards compatability.  # noqa: E501

        for example: “1:2:3” is BDB_uid=1, ENDPOINT_UID=2, PROXY_UID=3  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_endpoints_stats_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_endpoints_stats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/endpoints/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_jsonschema_get(self, **kwargs):  # noqa: E501
        """Get the jsonschema of RLEC objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_jsonschema_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object: Optional. The RLEC object name: ‘cluster’, ‘node’, ‘bdb’ etc.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_jsonschema_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_jsonschema_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_jsonschema_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the jsonschema of RLEC objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_jsonschema_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object: Optional. The RLEC object name: ‘cluster’, ‘node’, ‘bdb’ etc.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_jsonschema_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'object' in params:
            query_params.append(('object', params['object']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/jsonschema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ldap_mappings_get(self, **kwargs):  # noqa: E501
        """Get all ldap_mapping objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ldap_mappings_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ldap_mappings_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ldap_mappings_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all ldap_mapping objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ldap_mappings_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ldap_mappings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ldap_mappings_intuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete an LDAP mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  ldap_mapping_not_exist  An object does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The ldap_mapping unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ldap_mappings_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_ldap_mappings_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_ldap_mappings_intuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete an LDAP mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  ldap_mapping_not_exist  An object does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The ldap_mapping unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ldap_mappings_intuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_ldap_mappings_intuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ldap_mappings/(int:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ldap_mappings_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get a single ldap_mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  ldap_mapping_not_exist  An object does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The object’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ldap_mappings_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_ldap_mappings_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_ldap_mappings_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get a single ldap_mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  ldap_mapping_not_exist  An object does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The object’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ldap_mappings_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_ldap_mappings_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ldap_mappings/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ldap_mappings_intuid_put(self, **kwargs):  # noqa: E501
        """Update an existing ldap_mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  ldap_mapping_not_exist  An object does not exist  invalid_dn_param  A dn parameter has an illegal value  invalid_name_param  A name parameter has an illegal value  invalid_role_uids_param  A role_uids parameter has an illegal value  invalid_account_id_param  A account_id parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ldap_mappings_intuid_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ldap_mappings_intuid_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ldap_mappings_intuid_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update an existing ldap_mapping object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  ldap_mapping_not_exist  An object does not exist  invalid_dn_param  A dn parameter has an illegal value  invalid_name_param  A name parameter has an illegal value  invalid_role_uids_param  A role_uids parameter has an illegal value  invalid_account_id_param  A account_id parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_intuid_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ldap_mappings_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ldap_mappings/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ldap_mappings_post(self, **kwargs):  # noqa: E501
        """Create a new LDAP mapping.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  invalid_dn_param  A dn parameter has an illegal value  invalid_name_param  A name parameter has an illegal value  invalid_role_uids_param  A role_uids parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ldap_mappings_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ldap_mappings_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ldap_mappings_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new LDAP mapping.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  invalid_dn_param  A dn parameter has an illegal value  invalid_name_param  A name parameter has an illegal value  invalid_role_uids_param  A role_uids parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ldap_mappings_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ldap_mappings_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ldap_mappings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_license_get(self, **kwargs):  # noqa: E501
        """Returns the license details, including license string, expiration, and supported features.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_license_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_license_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_license_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_license_get_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the license details, including license string, expiration, and supported features.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_license_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_license_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/license', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_license_put(self, **kwargs):  # noqa: E501
        """Install a new license string.  # noqa: E501

        The license is being validated on this call and if not acceptable, an error is immediately returned.  The request must be a JSON object with a single key named “license”.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_license_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_license_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_license_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_license_put_with_http_info(self, **kwargs):  # noqa: E501
        """Install a new license string.  # noqa: E501

        The license is being validated on this call and if not acceptable, an error is immediately returned.  The request must be a JSON object with a single key named “license”.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_license_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_license_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/license', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_logs_get(self, **kwargs):  # noqa: E501
        """Get cluster events log. Returns an array of events.  # noqa: E501

        The following table describes the event object:  Field  Description  time  Timestamp when event happened.  type  Event type. Based on this additional fields may be available.  additional fields  Additional fields may be present based on event type.  Each event contains a timestamp, and event code. Based on the code the event object may contain additional fields describing the event.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stime: Optional start time before which we don’t want events.
        :param str etime: Optional end time after which we don’t want events.
        :param str order: Desc/asc - get events in descending or ascending order. Defaults to asc.
        :param str limit: Optional maximum number of events to return.
        :param str offset: Optional. Skip offset events before returning first one (useful for pagination).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_logs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_logs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cluster events log. Returns an array of events.  # noqa: E501

        The following table describes the event object:  Field  Description  time  Timestamp when event happened.  type  Event type. Based on this additional fields may be available.  additional fields  Additional fields may be present based on event type.  Each event contains a timestamp, and event code. Based on the code the event object may contain additional fields describing the event.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stime: Optional start time before which we don’t want events.
        :param str etime: Optional end time after which we don’t want events.
        :param str order: Desc/asc - get events in descending or ascending order. Defaults to asc.
        :param str limit: Optional maximum number of events to return.
        :param str offset: Optional. Skip offset events before returning first one (useful for pagination).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stime', 'etime', 'order', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_logs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_config_bdb_stringuid_post(self, **kwargs):  # noqa: E501
        """Use module runtime configuration command (if defined) to configure new arguments for the module.  # noqa: E501

        **Example request** :  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  db_not_exist  Database with given uid doesn’t exist in cluster.  missing_field  “module_name” or “module_args” are not defined in request  invalid_schema  json object received is not a dict object  param_error  “module_args” parameter was not parsed properly  module_not_exist  Module with given “module_name” does not exist for the database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_config_bdb_stringuid_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_config_bdb_stringuid_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_config_bdb_stringuid_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_modules_config_bdb_stringuid_post_with_http_info(self, **kwargs):  # noqa: E501
        """Use module runtime configuration command (if defined) to configure new arguments for the module.  # noqa: E501

        **Example request** :  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  db_not_exist  Database with given uid doesn’t exist in cluster.  missing_field  “module_name” or “module_args” are not defined in request  invalid_schema  json object received is not a dict object  param_error  “module_args” parameter was not parsed properly  module_not_exist  Module with given “module_name” does not exist for the database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_config_bdb_stringuid_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_config_bdb_stringuid_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules/config/bdb/(string:uid)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_get(self, **kwargs):  # noqa: E501
        """List available modules, i.e. modules stored within the CCS Example request:  # noqa: E501

        GET /modules HTTP/1.1 Host: 127.0.0.1:9443 Accept: */*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_modules_get_with_http_info(self, **kwargs):  # noqa: E501
        """List available modules, i.e. modules stored within the CCS Example request:  # noqa: E501

        GET /modules HTTP/1.1 Host: 127.0.0.1:9443 Accept: */*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_post(self, **kwargs):  # noqa: E501
        """Uploads a new module into the CCS  # noqa: E501

        The request must contain a Redis module bundled using RedisModule Packer. [https://github.com/RedisLabs/RAMP](https://github.com/RedisLabs/RAMP)  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  no_module  module wasn’t provided  invalid_module  Module either corrupted or packaged files are wrong  module_exists  Module already in system  min_redis_pack_version  Module isn’t supported yet in this redis pack  unsupported_module_capabilities  The module does not support required capabilities  os_not_supported  This module is only supported with these operating systems: <list supported OSs>  This endpoint does not support dependencies, see v2  dependencies_not_supported  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_modules_post_with_http_info(self, **kwargs):  # noqa: E501
        """Uploads a new module into the CCS  # noqa: E501

        The request must contain a Redis module bundled using RedisModule Packer. [https://github.com/RedisLabs/RAMP](https://github.com/RedisLabs/RAMP)  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  no_module  module wasn’t provided  invalid_module  Module either corrupted or packaged files are wrong  module_exists  Module already in system  min_redis_pack_version  Module isn’t supported yet in this redis pack  unsupported_module_capabilities  The module does not support required capabilities  os_not_supported  This module is only supported with these operating systems: <list supported OSs>  This endpoint does not support dependencies, see v2  dependencies_not_supported  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_stringuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete a Module.  # noqa: E501

        **Example request** :  The above request attempts to completely delete a module with unique ID.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_stringuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The Module unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_stringuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_stringuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_modules_stringuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete a Module.  # noqa: E501

        **Example request** :  The above request attempts to completely delete a module with unique ID.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_stringuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The Module unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_stringuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_modules_stringuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules/(string:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_stringuid_get(self, **kwargs):  # noqa: E501
        """Get specific available modules, i.e. modules stored within the CCS Example request:  # noqa: E501

        curl -k -u <CREDS> [https:/](https:/) /<HOST>/modules/10682975ad54eed67391cde5bb98f93e97298008d77410ad1548e45784f3c604 .. sourcecode:: http  GET /modules HTTP/1.1 Host: 127.0.0.1:9443 User-Agent: curl/7.51.0 Accept: */*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_stringuid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_stringuid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_stringuid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_modules_stringuid_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get specific available modules, i.e. modules stored within the CCS Example request:  # noqa: E501

        curl -k -u <CREDS> [https:/](https:/) /<HOST>/modules/10682975ad54eed67391cde5bb98f93e97298008d77410ad1548e45784f3c604 .. sourcecode:: http  GET /modules HTTP/1.1 Host: 127.0.0.1:9443 User-Agent: curl/7.51.0 Accept: */*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_stringuid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_stringuid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules/(string:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_modules_upgrade_bdb_stringuid_post(self, **kwargs):  # noqa: E501
        """Upgrades module version on specific BDB  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional db parameters  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  missing_module  Module is not present in cluster.  module_downgrade_unsupported  Module downgrade is not allowed.  redis_incompatible_version  Module min_redis_version is bigger the current redis version.  redis_pack_incompatible_version  Module min_redis_pack_version is bigger the current Redis Enterprise version.  unsupported_module_capabilities  New version of module does support all the capabilities needed for the database configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_upgrade_bdb_stringuid_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_modules_upgrade_bdb_stringuid_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_modules_upgrade_bdb_stringuid_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_modules_upgrade_bdb_stringuid_post_with_http_info(self, **kwargs):  # noqa: E501
        """Upgrades module version on specific BDB  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional db parameters  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  missing_module  Module is not present in cluster.  module_downgrade_unsupported  Module downgrade is not allowed.  redis_incompatible_version  Module min_redis_version is bigger the current redis version.  redis_pack_incompatible_version  Module min_redis_pack_version is bigger the current Redis Enterprise version.  unsupported_module_capabilities  New version of module does support all the capabilities needed for the database configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_modules_upgrade_bdb_stringuid_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_modules_upgrade_bdb_stringuid_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/modules/upgrade/bdb/(string:uid)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_node_intnode_id_fs_wd_fs_path_config_get(self, **kwargs):  # noqa: E501
        """Get fs wd path config for a specific node.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_node_intnode_id_fs_wd_fs_path_config_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_node_intnode_id_fs_wd_fs_path_config_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_node_intnode_id_fs_wd_fs_path_config_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_node_intnode_id_fs_wd_fs_path_config_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get fs wd path config for a specific node.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_node_intnode_id_fs_wd_fs_path_config_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_node_intnode_id_fs_wd_fs_path_config_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/node/(int:node_id)/fs_wd/(fs_path)/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_node_intnode_id_fs_wd_fs_path_config_put(self, **kwargs):  # noqa: E501
        """Update fs wd path config for a specific node.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_node_intnode_id_fs_wd_fs_path_config_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_node_intnode_id_fs_wd_fs_path_config_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_node_intnode_id_fs_wd_fs_path_config_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_node_intnode_id_fs_wd_fs_path_config_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update fs wd path config for a specific node.  # noqa: E501

        Returns JSON object with the following fields: average_threshold, immediate_threshold  See :ref: ` REST API  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_node_intnode_id_fs_wd_fs_path_config_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_node_intnode_id_fs_wd_fs_path_config_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/node/(int:node_id)/fs_wd/(fs_path)/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_actions_get(self, **kwargs):  # noqa: E501
        """Get the status of all currently executing, pending or completed actions on all nodes.  # noqa: E501

        See /nodes/(node_uid)/actions for reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_actions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_actions_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_actions_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_actions_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the status of all currently executing, pending or completed actions on all nodes.  # noqa: E501

        See /nodes/(node_uid)/actions for reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_actions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_actions_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_alerts_get(self, **kwargs):  # noqa: E501
        """Get all alert states for all nodes.  # noqa: E501

        Returns a hash of node uid’s and the alerts states for each node.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_alerts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_alerts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for all nodes.  # noqa: E501

        Returns a hash of node uid’s and the alerts states for each node.  See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignore_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_alerts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignore_settings' in params:
            query_params.append(('ignore_settings', params['ignore_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_alerts_intuid_alert_get(self, **kwargs):  # noqa: E501
        """Get node alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_intuid_alert_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_alerts_intuid_alert_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_alerts_intuid_alert_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_alerts_intuid_alert_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get node alert state.  # noqa: E501

        See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_intuid_alert_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignore_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_alerts_intuid_alert_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignore_settings' in params:
            query_params.append(('ignore_settings', params['ignore_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/alerts/(int:uid)/(alert)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_alerts_intuid_get(self, **kwargs):  # noqa: E501
        """Get all alert states for a node.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_intuid_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_alerts_intuid_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_alerts_intuid_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_alerts_intuid_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all alert states for a node.  # noqa: E501

        Returns a hash of alert objects and their state. See REST API alerts overview for a description of the alert state object.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_alerts_intuid_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ignore_settings: Optional retrieve updated alert state regardless if alert is enabled in cluster’s alert_settings. When not present a disabled alert will always be retrieved as disabled with a false state.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignore_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_alerts_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignore_settings' in params:
            query_params.append(('ignore_settings', params['ignore_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/alerts/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_get(self, **kwargs):  # noqa: E501
        """Get all cluster nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all cluster nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get single cluster node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_nodes_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get single cluster node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_nodes_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_intuid_put(self, uid, **kwargs):  # noqa: E501
        """Update a node object.  # noqa: E501

        Currently this operation supports editing the following attributes:  # addr  # external_addr  # recovery_path  # accept_servers  The addr attribute can only be updated for offline nodes and an error will be returned otherwise.  If an error status is returned, the body may contain a JSON object that describes the error.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_intuid_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the updated node. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_nodes_intuid_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Update a node object.  # noqa: E501

        Currently this operation supports editing the following attributes:  # addr  # external_addr  # recovery_path  # accept_servers  The addr attribute can only be updated for offline nodes and an error will be returned otherwise.  If an error status is returned, the body may contain a JSON object that describes the error.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_intuid_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the updated node. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_nodes_intuid_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_node_uid_actions_action_delete(self, action, **kwargs):  # noqa: E501
        """Cancel a queued or executing node action, or remove the status of a previously executed and completed action.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_delete(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action to cancel. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_node_uid_actions_action_delete_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_node_uid_actions_action_delete_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_nodes_node_uid_actions_action_delete_with_http_info(self, action, **kwargs):  # noqa: E501
        """Cancel a queued or executing node action, or remove the status of a previously executed and completed action.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_delete_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action to cancel. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_node_uid_actions_action_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_nodes_node_uid_actions_action_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(node_uid)/actions/(action)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_node_uid_actions_action_get(self, **kwargs):  # noqa: E501
        """v1_nodes_node_uid_actions_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_node_uid_actions_action_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_node_uid_actions_action_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_node_uid_actions_action_get_with_http_info(self, **kwargs):  # noqa: E501
        """v1_nodes_node_uid_actions_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_node_uid_actions_action_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(node_uid)/actions/(action)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_node_uid_actions_action_post(self, action, **kwargs):  # noqa: E501
        """Initiate a node action.  # noqa: E501

        The API allows only a single instance of any action type to be invoked at the same time, and violations of this requirement will result with a 409 CONFLICT response.  The caller is expected to query and process the results of the previously executed instance of the same action, which will be removed as soon as the new one is submitted.  The body content may provide additional action details. Currently it is not used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_post(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action required. Currently supported actions are: remove : removes the node from the cluster after migrating all bound resources to other nodes. As soon as a successful remove request is received, the cluster will no longer automatically migrate resources (shards/endpoints) to the node, even if the remove task fails at some point. maintenance_on : creates a snapshot of the node, migrate shards to other nodes and makes sure it can undergo maintenance. If there aren’t enough resources to migrate shards out of the maintained node, set “keep_slave_shards”: true to keep the slave shards in place but demote any master shards. maintenance_off : restores node to the state it was before maintenance started. By default it uses the latest node snapshot. Using “snapshot_name”: “…” can be used to restore from a different snapshot. To avoid restoring shards at the node, use “skip_shards_restore”: true . enslave_node : enslave all bound resources. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_node_uid_actions_action_post_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_node_uid_actions_action_post_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_nodes_node_uid_actions_action_post_with_http_info(self, action, **kwargs):  # noqa: E501
        """Initiate a node action.  # noqa: E501

        The API allows only a single instance of any action type to be invoked at the same time, and violations of this requirement will result with a 409 CONFLICT response.  The caller is expected to query and process the results of the previously executed instance of the same action, which will be removed as soon as the new one is submitted.  The body content may provide additional action details. Currently it is not used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_action_post_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The name of the action required. Currently supported actions are: remove : removes the node from the cluster after migrating all bound resources to other nodes. As soon as a successful remove request is received, the cluster will no longer automatically migrate resources (shards/endpoints) to the node, even if the remove task fails at some point. maintenance_on : creates a snapshot of the node, migrate shards to other nodes and makes sure it can undergo maintenance. If there aren’t enough resources to migrate shards out of the maintained node, set “keep_slave_shards”: true to keep the slave shards in place but demote any master shards. maintenance_off : restores node to the state it was before maintenance started. By default it uses the latest node snapshot. Using “snapshot_name”: “…” can be used to restore from a different snapshot. To avoid restoring shards at the node, use “skip_shards_restore”: true . enslave_node : enslave all bound resources. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_node_uid_actions_action_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_nodes_node_uid_actions_action_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(node_uid)/actions/(action)', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_node_uid_actions_get(self, action, **kwargs):  # noqa: E501
        """Get the status of a currently executing, queued or completed action, or all actions, on a specific node.  # noqa: E501

        If no action is specified, an array with all actions for the specified node is returned, encapsualted in a JSON object as follows:  In this form, if no actions are available the response will include an empty array.  See REST API actions overview for more details on action status and error codes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_get(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The action to check. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_node_uid_actions_get_with_http_info(action, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_node_uid_actions_get_with_http_info(action, **kwargs)  # noqa: E501
            return data

    def v1_nodes_node_uid_actions_get_with_http_info(self, action, **kwargs):  # noqa: E501
        """Get the status of a currently executing, queued or completed action, or all actions, on a specific node.  # noqa: E501

        If no action is specified, an array with all actions for the specified node is returned, encapsualted in a JSON object as follows:  In this form, if no actions are available the response will include an empty array.  See REST API actions overview for more details on action status and error codes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_node_uid_actions_get_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: The action to check. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_node_uid_actions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `v1_nodes_node_uid_actions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/(node_uid)/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_stats_get(self, **kwargs):  # noqa: E501
        """Get stats for all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_stats_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_stats_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_stats_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get stats for all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_stats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_stats_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get stats for node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_nodes_stats_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get stats for node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_stats_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_nodes_stats_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/stats/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_stats_last_get(self, **kwargs):  # noqa: E501
        """Get stats for all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_last_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_stats_last_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_stats_last_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_nodes_stats_last_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get stats for all nodes.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_last_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_stats_last_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/stats/last', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_nodes_stats_last_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get the last stats of a node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_last_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_nodes_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_nodes_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_nodes_stats_last_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get the last stats of a node.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_nodes_stats_last_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the node requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_nodes_stats_last_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_nodes_stats_last_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/nodes/stats/last/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ocsp_get(self, **kwargs):  # noqa: E501
        """Get the OCSP configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————–+——————————————————+ | Code | Description | +===================================+======================================================+ | ocsp_unsupported_by_capability | Not all nodes support OCSP capability | +———————————–+——————————————————+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ocsp_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ocsp_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ocsp_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the OCSP configuration, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————–+——————————————————+ | Code | Description | +===================================+======================================================+ | ocsp_unsupported_by_capability | Not all nodes support OCSP capability | +———————————–+——————————————————+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ocsp_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ocsp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ocsp_put(self, **kwargs):  # noqa: E501
        """Set or update cluster OCSP configuration.  # noqa: E501

        **Example request** :  Possible ` error_code`s:  Code  Description  invalid_schema  An illegal parameter, or a parameter with illegal value  no_responder_url  Trying to enable OCSP with no responder URL configured.  ocsp_unsupported_by_capability  Not all nodes support OCSP capability  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ocsp_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ocsp_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ocsp_put_with_http_info(self, **kwargs):  # noqa: E501
        """Set or update cluster OCSP configuration.  # noqa: E501

        **Example request** :  Possible ` error_code`s:  Code  Description  invalid_schema  An illegal parameter, or a parameter with illegal value  no_responder_url  Trying to enable OCSP with no responder URL configured.  ocsp_unsupported_by_capability  Not all nodes support OCSP capability  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ocsp_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ocsp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ocsp_status_get(self, **kwargs):  # noqa: E501
        """Get the OCSP status, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————–+————————————————————–+ | Code | Description | +===================================+==============================================================+ | ocsp_unsupported_by_capability | Not all nodes support OCSP capability | +———————————–+————————————————————–+ | invalid_ocsp_response | The server returned a response that is not OCSP-compatible | +———————————–+————————————————————–+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ocsp_status_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ocsp_status_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ocsp_status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the OCSP status, as JSON.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s: +———————————–+————————————————————–+ | Code | Description | +===================================+==============================================================+ | ocsp_unsupported_by_capability | Not all nodes support OCSP capability | +———————————–+————————————————————–+ | invalid_ocsp_response | The server returned a response that is not OCSP-compatible | +———————————–+————————————————————–+  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ocsp_status_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ocsp/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_ocsp_test_post(self, **kwargs):  # noqa: E501
        """Manually initiate a query to the OCSP server, and get the response as JSON. The staple is stored if the ocsp feature is enabled  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  no_responder_url  Trying to test OCSP status with no responder URL configured.  ocsp_unsupported_by_capability  Not all nodes support OCSP capability  task_queued_for_too_long  OCSP polling task was in status “queued” for over 5 seconds  invalid_ocsp_response  The server returned a response that is not OCSP-compatible  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_test_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_ocsp_test_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_ocsp_test_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_ocsp_test_post_with_http_info(self, **kwargs):  # noqa: E501
        """Manually initiate a query to the OCSP server, and get the response as JSON. The staple is stored if the ocsp feature is enabled  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  no_responder_url  Trying to test OCSP status with no responder URL configured.  ocsp_unsupported_by_capability  Not all nodes support OCSP capability  task_queued_for_too_long  OCSP polling task was in status “queued” for over 5 seconds  invalid_ocsp_response  The server returned a response that is not OCSP-compatible  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_ocsp_test_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_ocsp_test_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/ocsp/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_redis_acls_get(self, **kwargs):  # noqa: E501
        """Get all redis_acl objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_redis_acls_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_redis_acls_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_redis_acls_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all redis_acl objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_redis_acls_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/redis_acls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_redis_acls_intuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete a redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The redis_acl unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_redis_acls_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_redis_acls_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_redis_acls_intuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete a redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The redis_acl unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_redis_acls_intuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_redis_acls_intuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/redis_acls/(int:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_redis_acls_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get a single redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The object’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_redis_acls_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_redis_acls_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_redis_acls_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get a single redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The object’s unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_redis_acls_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_redis_acls_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/redis_acls/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_redis_acls_intuid_put(self, **kwargs):  # noqa: E501
        """Update an existing redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  invalid_param  A parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_redis_acls_intuid_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_redis_acls_intuid_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_redis_acls_intuid_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update an existing redis_acl object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  invalid_param  A parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_intuid_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_redis_acls_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/redis_acls/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_redis_acls_post(self, **kwargs):  # noqa: E501
        """Create a new redis_acl object (a named redis acl)  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  invalid_param  A parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_redis_acls_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_redis_acls_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_redis_acls_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new redis_acl object (a named redis acl)  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  invalid_param  A parameter has an illegal value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_redis_acls_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_redis_acls_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/redis_acls', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_roles_get(self, **kwargs):  # noqa: E501
        """Get all role objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_roles_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_roles_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_roles_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all role objects.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_roles_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_roles_intuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete a role object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The role unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_roles_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_roles_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_roles_intuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete a role object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The role unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_roles_intuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_roles_intuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles/(int:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_roles_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get a single role object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC role unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_roles_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_roles_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_roles_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get a single role object.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC role unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_roles_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_roles_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_roles_intuid_put(self, **kwargs):  # noqa: E501
        """Update an existing role object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  change_last_admin_role_not_allowed  At least one user with admin role should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_roles_intuid_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_roles_intuid_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_roles_intuid_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update an existing role object.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  change_last_admin_role_not_allowed  At least one user with admin role should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_intuid_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_roles_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_roles_post(self, **kwargs):  # noqa: E501
        """Create a new role.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_roles_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_roles_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_roles_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new role.  # noqa: E501

        **Example request** :  **Example response** :  Possible ` error_code`s:  Code  Description  unsupported_resource  The cluster is not yet capable to handle this resource type. This could happen in a partially-upgraded cluster, where some of the nodes are still of a previous version.  name_already_exists  An object of the same type and name exists  missing_field  A needed field is missing  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_roles_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_roles_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_shards_stats_get(self, **kwargs):  # noqa: E501
        """Get stats for all shards.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str parent_uid: Optional return only shard from the given BDB ID.
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_shards_stats_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_shards_stats_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_shards_stats_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get stats for all shards.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str parent_uid: Optional return only shard from the given BDB ID.
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str metrics: Optional comma separated list of metric names for which we want statistics (default is all).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['parent_uid', 'interval', 'stime', 'etime', 'metrics']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_shards_stats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent_uid' in params:
            query_params.append(('parent_uid', params['parent_uid']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501
        if 'metrics' in params:
            query_params.append(('metrics', params['metrics']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/shards/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_shards_stats_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get stats for a specific shard.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the shard requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_shards_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_shards_stats_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_shards_stats_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get stats for a specific shard.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the shard requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_shards_stats_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_shards_stats_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/shards/stats/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_shards_stats_last_get(self, **kwargs):  # noqa: E501
        """Get last stats for all shards.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_last_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_shards_stats_last_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_shards_stats_last_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_shards_stats_last_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get last stats for all shards.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_last_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_shards_stats_last_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/shards/stats/last', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_shards_stats_last_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get stats for a specific shard.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_last_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the shard requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_shards_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_shards_stats_last_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_shards_stats_last_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get stats for a specific shard.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_shards_stats_last_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The unique ID of the shard requested. (required)
        :param str interval: Optional time interval for which we want stats: 1sec/10sec/5min/15min/1hour/12hour/1week. Default: 1sec.
        :param str stime: Optional start time from which we want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :param str etime: Optional end time after which we don’t want the stats. Should comply with the [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601) format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid', 'interval', 'stime', 'etime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_shards_stats_last_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_shards_stats_last_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'stime' in params:
            query_params.append(('stime', params['stime']))  # noqa: E501
        if 'etime' in params:
            query_params.append(('etime', params['etime']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/shards/stats/last/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_suffix_stringname_get(self, name, **kwargs):  # noqa: E501
        """Get single DNS suffix.  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional suffix parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_suffix_stringname_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The unique Name of the suffix requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_suffix_stringname_get_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_suffix_stringname_get_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def v1_suffix_stringname_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get single DNS suffix.  # noqa: E501

        **Example request** :  **Example response** :  See Object Attributes for more details on additional suffix parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_suffix_stringname_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The unique Name of the suffix requested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_suffix_stringname_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `v1_suffix_stringname_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/suffix/(string:name)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_suffixes_get(self, **kwargs):  # noqa: E501
        """Get all DNS suffixes in the cluster.  # noqa: E501

        The response body contains a JSON array with all suffixes, represented as suffix objects.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_suffixes_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_suffixes_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_suffixes_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_suffixes_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all DNS suffixes in the cluster.  # noqa: E501

        The response body contains a JSON array with all suffixes, represented as suffix objects.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_suffixes_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_suffixes_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/suffixes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_authorize_post(self, **kwargs):  # noqa: E501
        """Authorize a RLEC user.  # noqa: E501

        In order to use the rest-api a user must be authorized using JSON Web Token (JWT) In order to obtain a valid token, a request should be made to **/users/authorize** with a valid username and password.  **Example request** :  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_expired  The password has expired and must be changed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_authorize_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_authorize_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_authorize_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_authorize_post_with_http_info(self, **kwargs):  # noqa: E501
        """Authorize a RLEC user.  # noqa: E501

        In order to use the rest-api a user must be authorized using JSON Web Token (JWT) In order to obtain a valid token, a request should be made to **/users/authorize** with a valid username and password.  **Example request** :  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_expired  The password has expired and must be changed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_authorize_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_authorize_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_get(self, **kwargs):  # noqa: E501
        """Get all RLEC users.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all RLEC users.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_intuid_delete(self, uid, **kwargs):  # noqa: E501
        """Delete a RLEC user.  # noqa: E501

        **Example request** :  The above request attempts to completely delete a user with unique ID 1.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_delete(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_intuid_delete_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_users_intuid_delete_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Delete a RLEC user.  # noqa: E501

        **Example request** :  The above request attempts to completely delete a user with unique ID 1.  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_delete_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_intuid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_users_intuid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/(int:uid)', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_intuid_get(self, uid, **kwargs):  # noqa: E501
        """Get a single RLEC user.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_get(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_intuid_get_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_users_intuid_get_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Get a single RLEC user.  # noqa: E501

        **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_get_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_intuid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_users_intuid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/(int:uid)', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_intuid_put(self, uid, **kwargs):  # noqa: E501
        """Update a RLEC user configuration.  # noqa: E501

        **Example request** :  The response includes the updated user object.  **Example response** :  Note that with RBAC-enabled clusters the role is replaced with role_uids.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to the old password.  email_already_exists  The given email is already taken.  change_last_admin_role_not_allowed  At least one user with admin role should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_put(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_intuid_put_with_http_info(uid, **kwargs)  # noqa: E501
            return data

    def v1_users_intuid_put_with_http_info(self, uid, **kwargs):  # noqa: E501
        """Update a RLEC user configuration.  # noqa: E501

        **Example request** :  The response includes the updated user object.  **Example response** :  Note that with RBAC-enabled clusters the role is replaced with role_uids.  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to the old password.  email_already_exists  The given email is already taken.  change_last_admin_role_not_allowed  At least one user with admin role should exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_intuid_put_with_http_info(uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uid: The RLEC user unique ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_intuid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `v1_users_intuid_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/(int:uid)', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_password_delete(self, **kwargs):  # noqa: E501
        """Delete a password from the list of an internal user’s passwords.  # noqa: E501

        The request must contain a single JSON with the username and an existing password to be deleted.  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  cannot_delete_last_password  Cannot delete the last password of a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_password_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_password_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_password_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete a password from the list of an internal user’s passwords.  # noqa: E501

        The request must contain a single JSON with the username and an existing password to be deleted.  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  cannot_delete_last_password  Cannot delete the last password of a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_password_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/password', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_password_post(self, **kwargs):  # noqa: E501
        """Add a new password to an internal user’s passwords list.  # noqa: E501

        The request must contain a single JSON with the username, an existing password and a new password to be added.  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to one of the already existing passwords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_password_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_password_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_password_post_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new password to an internal user’s passwords list.  # noqa: E501

        The request must contain a single JSON with the username, an existing password and a new password to be added.  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to one of the already existing passwords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_password_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_password_put(self, **kwargs):  # noqa: E501
        """Reset the password list of an internal user to include a (single) new password.  # noqa: E501

        The request must contain a single JSON with the username, a currently valid password and the new password:  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to one of the already existing passwords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_password_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_password_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_password_put_with_http_info(self, **kwargs):  # noqa: E501
        """Reset the password list of an internal user to include a (single) new password.  # noqa: E501

        The request must contain a single JSON with the username, a currently valid password and the new password:  **Example request** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  new_password_same_as_current  The given new password is identical to one of the already existing passwords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_password_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_password_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_post(self, **kwargs):  # noqa: E501
        """Create a new RLEC user.  # noqa: E501

        The request must contain a single JSON user object, with an email and a password:  **Example request** :  Note that with RBAC-enabled clusters the role is replaced with role_uids.  “email_alerts” can be configured either as: true - user will receive alerts for all databases configured in “bdbs_email_alerts” or for all the databases if “bdbs_email_alerts” is not configured. “bdbs_email_alerts” cab be a list of databases uids or [‘all’] meaning all databases. false - user will not receive alerts for any databases The response includes the newly created user object.  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  email_already_exists  The given email is already taken.  name_already_exists  The given name is already taken.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new RLEC user.  # noqa: E501

        The request must contain a single JSON user object, with an email and a password:  **Example request** :  Note that with RBAC-enabled clusters the role is replaced with role_uids.  “email_alerts” can be configured either as: true - user will receive alerts for all databases configured in “bdbs_email_alerts” or for all the databases if “bdbs_email_alerts” is not configured. “bdbs_email_alerts” cab be a list of databases uids or [‘all’] meaning all databases. false - user will not receive alerts for any databases The response includes the newly created user object.  **Example response** :  When errors are reported, the server may return a JSON object with error_code and message field that provide additional information. The following are possible error_code values:  Code  Description  password_not_complex  The given password is not complex enough (Only work when the password_complexity feature is enabled).  email_already_exists  The given email is already taken.  name_already_exists  The given name is already taken.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v1_users_refresh_jwt_post(self, **kwargs):  # noqa: E501
        """Get a new authentication token.  # noqa: E501

        Takes a valid token and returns a token that is issued at the time of the request.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_refresh_jwt_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v1_users_refresh_jwt_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v1_users_refresh_jwt_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v1_users_refresh_jwt_post_with_http_info(self, **kwargs):  # noqa: E501
        """Get a new authentication token.  # noqa: E501

        Takes a valid token and returns a token that is issued at the time of the request.  **Example request** :  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v1_users_refresh_jwt_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v1_users_refresh_jwt_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/refresh_jwt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v2_bdbs_post(self, **kwargs):  # noqa: E501
        """Create a new database in the cluster. See /v1/bdbs for more information. The database’s configuration should be under the “bdb” field.  # noqa: E501

        Including a recovery_plan within the request body will result in the database being loaded from the persistence files according to the recovery plan. The recovery plan must match the number of shards requested for the database. The persistence files must exist in the locations specified by the recovery plan. The persistence files must belong to a database with the same shard settings as the one being created (slot range distribution and shard_key_regex), otherwise the operation will fail or yield unpredictable results.  Creating a database with a shards_blueprint and a recovery plan may result in the shards_blueprint’s shard placement only partially fulfilled.  In order to retrieve a recovery plan according to the database’s existing persistence files, use the GET /bdbs/<uid>/actions/recover API.  Example request:  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v2_bdbs_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v2_bdbs_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v2_bdbs_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v2_bdbs_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new database in the cluster. See /v1/bdbs for more information. The database’s configuration should be under the “bdb” field.  # noqa: E501

        Including a recovery_plan within the request body will result in the database being loaded from the persistence files according to the recovery plan. The recovery plan must match the number of shards requested for the database. The persistence files must exist in the locations specified by the recovery plan. The persistence files must belong to a database with the same shard settings as the one being created (slot range distribution and shard_key_regex), otherwise the operation will fail or yield unpredictable results.  Creating a database with a shards_blueprint and a recovery plan may result in the shards_blueprint’s shard placement only partially fulfilled.  In order to retrieve a recovery plan according to the database’s existing persistence files, use the GET /bdbs/<uid>/actions/recover API.  Example request:  **Example response** :  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v2_bdbs_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_bdbs_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v2/bdbs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
