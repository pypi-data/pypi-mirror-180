doc_1_sting = """
ЗАНЯТИЯ 1-2
Тема: Строки.
Строка - это последовательность символов, заключенная в
апострофы. При описании переменной для работы со строками
используется тип String.
Var
s: String;
Такая запись означает, что в программе будет использоваться
строковая переменная s с неограниченной длиной строки.
Строки можно складывать. Эта операция называется конкатенация,
или сложение, или слияние строк и обозначается знаком плюс.
Например:
Var
s, st: String;
Begin
s:=’Мы изучаем’; //В первую строку кладем значение «Мы
изучаем»
st:=’ Pascal'; //Во вторую строку кладем значение « Pascal»
s:=s+st; //Складываем эти две строки
End;
В результате выполнения данной программы мы получим в
переменной S строку: Мы изучаем Pascal.
Строки можно сравнивать.
Сравнение осуществляется посимвольно слева направо в
соответствии с тем порядком, в котором символы хранятся в
компьютере. Латинские буквы хранятся в алфавитном порядке, цифры –
от 0 до 9 в порядке возрастания.
Пример:
‘AB’ > ‘АА’
‘A’ < ‘АB’
‘DC’ > ‘ABCDE’
‘ABCE’ > ‘АBCD’
Для работы со строками существует несколько стандартных
функция и процедур. Рассмотрим их.
Таблица
стандартных процедур и функций работы со строками
Процедуры работы со строками
Имя Тип параметров Назначение
Delete ( St, Poz, N ) St: string;
Poz, N: integer;
Удаление N символов строки St, начиная с
позиции Poz
Insert ( St1, St2, Poz ) St1,St2: string;
Poz: integer;
Вставка строки St1 в строку St2, начиная с
позиции Poz
Функции работы со строками
Имя Типы результата и
параметров
Назначение
Copy ( St, Poz, N ) Результат: string;
St: string;
Poz, N: integer;
Копирует из строки St подстроку длиной N
символов, начиная с позиции Poz.
Length ( St ) Результат: integer;
St: string;
Вычисляет длину строки St, то есть число
символов, из которых состоит строка.
Pos ( St1, St2 ) Тип: integer;
St1,St2: string;
Обнаруживает первое появление
в строке St2 подстроки St1. Значением
функции является номер той позиции, где
находится первый символ подстроки St1.
Если в St2 подстроки St1 не найдено,
результат равен 0.
Примеры:
Процедура Delete
Значение St Выражение Значение St, после выполнения
процедуры
'abcdef' Delete(St,4,2) 'abcf'
'Turbo-Pascal' Delete(St,1,6) 'Pascal'
Процедура Insert
Значение St1 Значение St2 Выражение Значение St2,
после
выполнения
процедуры
'Turbo' '-Pascal' Insert(St1,St2,1) 'Turbo-Pascal'
'-Pascal' 'Turbo' Insert(St1,St2,6) 'Turbo-Pascal'
Функция Copy
Значение St Выражение Значение Str, после выполнения
процедуры
'abcdefg' Str:=Copy(St,2,3); 'bcd'
'abcdefg' Str:=Copy(St,4,4); 'defg'
Функция Length
Значение St Выражение Значение N, после выполнения
процедуры
'abcdefg' N:=Length(St); 7
'Turbo-Pascal' N:=Length(St); 12
Функция Pos
Значение St2 Выражение Значение N, после выполнения
процедуры
'abcdef' N:=Pos('de',St2); 4
'abcdef' N:=Pos('r',St2); 0
Примеры
Задача 1.
Подсчитать количество пробелов в строке, введенной с клавиатуры.
procedure vvod(var st:string);
begin
 Writeln('Vvedite stroku');
 Readln(st);
end;
procedure calc(st:string; var N:integer);
begin
 n:=0; {Обнуляем счетчик пробелов}
 While pos(' ',St)<>0 do {Пока позиция пробела в строке St не 0 }
 begin
 delete(ST,pos(' ',st),1); {Удаляем пробел из строки St }
 n:=n+1; {Значение счетчика пробелов увеличиваем на 1}
 end;
end;
var
s:string;
k:integer;
begin
 vvod(s); {Ввести строку S}
 calc(S,k); {Подсчитать количество пробелов K в строке S}
 writeln('Kol-vo probelov v stroke ',S,' = ',K); {Вывести K}
end.
Задача 2.
Удалить все цифры из строки, введенной с клавиатуры.
procedure vvod(var st:string);
begin
 Writeln('Vvedite stroku');
 Readln(st);
end;
procedure calc(var st:string);
const
 s1='1234567890'; {Задаем строку цифр}
var
 i:integer;
begin
 i:=1; {Берем символ с 1 места (i- номер символа в строке)}
 While i<=length(St) do {Пока номер символа в строке меньше
 или равен длины строки St}
 if pos(copy(st,i,1),s1)<>0 then {если символ, скопированный с i-ого места
 строки st, есть в строке цифр S1, то}
 delete(ST,i,1) {удаляем с i-ого места 1 символ}
 else {иначе}
 i:=i+1; {Берем символ со следующего места}
 end;
var
s:string;
k:integer;
begin
 vvod(s);{Ввести строку S}
 calc(S);{Удалить из строки S все цифры}
 writeln('Poluchennaia stroka ',S);{Вывести строку S}
end.
"""
doc_2_array = """
Массивы
Занятие 1. Именованные константы, собственные типы,
одномерные массивы: понятие, заполнение, вывод.
Именованные константы
Константами называются величины, которые не меняются в процессе
выполнения программы. Константы, так же как и переменные, имеют свой тип.
Константы бывают неименованные и именованные.
Примеры неименованных констант:
100 — Integer
2.7 — Real
7.12457е-03 — Real
TRUE — Boolean
14.0 — Real
-37 — Integer
‘asderc’ — String
В некоторых случаях удобно использовать именованные константы. Для
этого в блоке объявлений программы задается имя константы и ее значение.
Формат описания именованных констант:
Const
<имя константы> = <значение>;
Имя константы задается по тем же правилам что и имя переменной. Тип
именованной константы определяется автоматически в соответствии с типом ее
значения.
Именованные константы обычно используют для наглядности и для
настройки программы.
Собственные типы
В языке Паскаль имеется возможность описывать новые типы.
Пример описания собственных типов:
type
kg = integer;
cm = integer;
var
Weight : kg;
Size : cm:
Что дает нам использование собственных типов? Во-первых, лучшее
понимание программы, наглядность. Кроме того, если в дальнейшем окажется,
что мы неудачно выбрали тип для описания переменных то достаточно поменять
тип только в одном месте, а не во всех местах, где мы описывали переменные.
Одномерные массивы
Массив – это совокупность данных одного типа, имеющая одно общее имя,
но разные индексы и значения. Например, список учащихся класса. Имя каждого
элемента данного массива – это «Ученик», в журнале каждому ученику присвоен
номер – это индекс элементов массива, а вот кто этот ученик – это значение
элемента массива.
Формат описания массива:
<имя массива> : ARRAY [<нач. зн.> ..< кон. знач. индекса>] OF <тип эл-в> ;
Описание массива включает в себя:
1. имя массива;
2. ключевое слово ARRAY;
3. начальное и конечное значение индекса, которые определяют границы
изменения индексов, например: 1..40, -2..2, 0..10. Нижняя граница показывает
наименьшее возможное значение индекса, верхняя - наибольшее. Очевидно,
что нижняя граница не может превосходить верхнюю. Нижняя граница
отделяется от верхней двумя точками. Индекс должен иметь порядковый тип
(это такой тип, для элементов которого определён предыдущий и
последующий элементы). Из них нам пока известны: все целочисленные типы,
логический тип. В качестве индекса могут выступать только константы, то есть
размер массива задаётся при написании программы и не может быть изменён
в ходе работы программы;
4. 4) тип элементов массива.
Пример описания массива
A: array[1..10] of real;
Это массив A, состоящий из 10 элементов, каждый из которых является
вещественным числом. Это означает, что компилятор оставит в памяти 10 ячеек
для чисел типа Real. Причем все эти ячейки будут называться A, но каждая из них
будет иметь свой номер от 1 до 10.
Важно, что к элементу массива можно обращаться по индексу. При этом
индекс может быть выражением соответствующего типа.
Например
X:=5;
A[x+2]:=4.5
Здесь элементу массива со значение индекса равным 7 (5+2), присваивается
число 4.5.
Использование обращения по индексу позволяет эффективней решать
задачи. Например, чтобы присвоить всем элементам массива ноль достаточно
написать следующий цикл
For i:=1 To 10 do
 A[i]:=0;
Для того, чтобы массив можно было передать в качестве параметра в
процедуру, он должен быть обязательно описан собственным типом, например
Type
 Mas = array[1..30] of integer;
…………………..
…………………..
Var
 A : mas;
Теперь рассмотрим задачу. Заполнить массив, состоящий из N элементов,
целыми четными числами по порядку (2, 4, 6 и т.д.) и вывести массив на экран.
Запишем алгоритм решение задачи в комментариях.
Begin
 //Заполняем массив A четными числами
 //Выводим массив A
End.
Сопоставим каждой фразе алгоритма операторы языка Паскаль.
Begin
Zapoln(А); // Заполняем массив A четными числами
Vyvod(a); // Выводим массив A
End.
Прежде, чем описать необходимые нам для решения задачи процедуры и
функции, отметим, мы должны задать количество элементов массива N (чтобы
компилятор знал, сколько оставить ячеек в памяти для массива) и для того, чтобы
передавать массив как параметр процедуры, необходимо описать собственный
тип массив.
Const
N=10;
Type
Mas = array[1..N] of integer;
…………………..
…………………..
Var
A : Mas;
Begin
Zapoln(А); // Заполняем массив A четными числами
Vyvod('Полученный массив ',a); // Выводим массив A
End.
Теперь на месте пустых строк опишем необходимые нам процедуры.
procedure Zapoln(var M:mas);
var
i : integer;
begin
 for i:=1 to N do // Для всех номеров i от 1 до N выполнить
m[i]:= 2*i; // Элементу массива M i-ому присвоить четное значение (2*i)
end;
procedure vyvod( S:string; M:mas);
var
i:integer;
begin
writeln(s);
for i:=1 to N do // Для всех номеров i от 1 до N выполнить
 write(m[i]:5); // Вывести i-ый элемент массива M на экран
end;
Заполнять массив можно не только с помощью оператора, но и, например,
вводить значения элементов с клавиатуры.
Задания.
Задание 1 (Задание 1 из 1-ого занятия из Moodle)
Заполнить массив размером N целыми числами последовательно от 1 до N.
Вывести его на экран. Найти сумму элементов массива и вывести ее на экран.
Задание 2 (Задание 2 из 1-ого занятия из Moodle)
Заполнить массив размером N целыми числами последовательно от N до 1.
Вывести его на экран. Найти количество элементов массива, делящихся на 3 без
остатка.
Задание 3 (Задание 3 из 1-ого занятия из Moodle)
Заполнить массив размером N квадратами целых чисел последовательно от
1
2
до N2
. Вывести его на экран. Найти среднее арифметическое элементов
массива и вывести его на экран.
Задание 4 (Задание 1 из 2-ого занятия из Moodle)
Имеется массив вещественных чисел размером N. Заполнить его числами,
введёнными с клавиатуры. Вывести его на экран. Посчитать, сколько элементов
массива больше среднего арифметического всех элементов.
Задание 5 (Задание 3 из 2-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его числами, как
положительными, так и отрицательными, введёнными с клавиатуры. Вывести его
на экран. Посчитать сумму положительных двухзначных чисел, которые
заканчиваются на цифру 7. Если таких чисел нет, то вывести сообщение "Таких
чисел нет"
Задание 6 (Задание 4 из 2-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его числами,
введёнными с клавиатуры. Вывести его на экран. Заменить каждый элемент
массива на сумму его цифр. Получившийся массив вывести на экран.
Задание 7* (Задание 5 из 2-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его числами,
введёнными с клавиатуры. Вывести его на экран. Переставить элементы массива
следующим образом: первый на место второго, второй на место третьего, и т.д.,
последний на место первого (сдвиг по кругу вправо). Получившийся массив
вывести на экран."""
doc_3_array_2 = """
Массивы
Занятие 2. Нахождение максимального, минимального элементов
массива. Обмен элементов в массиве.
Заполнять массив можно и случайными числами.
Рассмотрим задачу: заполнить массив, состоящий из N элементов, целыми
числами, значения которых находятся в указанном диапазоне от n1 от n2 (n1 и n2
вводятся с клавиатуры). Вывести массив на экран. Найти минимальный элемент,
вывести его на экран. Поменять местами первый и последний элементы массива.
Вывести полученный массив на экран.
Запишем алгоритм решение задачи в комментариях.
Begin
 //Вводим диапазон n1 и n2 изменения значений элементов массива
 //Заполняем массив A числами из указанного диапазона от n1 до n2
 //Выводим массив на экран
 //Находим максимальный элемент массива Amax.
 //Выводим Amax
 //Меняем местами первый и последний элементы массива A
 //Выводим массив на экран
End.
Сопоставим каждой фразе алгоритма операторы языка Паскаль.
Begin
Vvod(n1, n2); //Вводим диапазон n1 и n2 изменения значений элементов массива
Zapoln(A, n1, n2); //Заполняем массив A случайными числами в диапазоне от n1 до n2
Vyvod(‘Исходный массив ’,A); // Выводим массив A на экран.
Amax:=max(A); // Находим максимальный элемент массива Amax
Writeln(‘Максимальный элемент массива ’, Amax:5); // Выводим Amax
Change(A[1], A[n]); //Меняем местами первый и последний элементы массива A
Vyvod('Полученный массив ',A); //Выводим массив на экран
End.
Определим необходимые константы, типы, переменные, процедуры и функции.
Const
n=15;
Type
mas1= array[1..n] of integer;
Процедура ввода диапазона изменения значений элементов массива, процедура
заполнения массива и процедура вывода массива на экран, были разобраны в
предыдущих занятиях. Их объявление недолжно быть для вас сложно.
Procedure Vvod(s:string; var ch1,ch2:integer);
Begin
writeln(s);
readln(ch1, ch2);
end;
Procedure Zapoln(var M:mas1; a, b:integer);
Var
i:integer;
begin
for i:=1 to n do //Для каждого номера i от 1 до N
m[i]:=random(b-a+1)+a; // Присвоим i-ому элементу массива случайное значение
 в диапазоне от a до b
end;
Procedure Vyvod(s:string; M:mas1);
Var
i:integer;
Begin
writeln(s);
for i:=1 to n do
 write(m[i]:5);
writeln;
end;
А вот про функцию нахождения максимального элемента массива и про процедуру
обмена элементов в массиве немного поговорим.
Массив – это совокупность переменных одного типа. То есть поменять местами два
элемента массива – это все равно, что поменять местами две переменный. А такую
задачу мы уже делали в прошлом году. Вспомним, как поменять значения двух
переменных через третью переменную.
Procedure Change(var ch1,ch2:integer);
Var
tmp:integer;
Begin
tmp:=ch1;
ch1:=ch2;
ch2:=tmp;
end;
Теперь рассмотрим функцию для нахождения максимального элемента в массиве.
Сначала, как обычно, напишем алгоритм решения в комментариях. Отметим, что нам
будут нужны две дополнительные переменные для хранения максимального элемента
массива и счетчик для индекса текущего элемента массива.
Function max(m:mas1):integer;
Var
i, maxEl: integer; // Счетчик, переменная для хранения максимального элемента
Begin
maxEl:=m[1]; // Предположим, что первый элемент массива максимальный
for i:=2 to n do // Для каждого номера i от 2 до N
 if m[i]>maxEl then // если i-ый элемент больше максимального, то
 maxEl:=m[i]; // переопределяем максимальный элемент
max:=maxEl;
end;
Var
A:mas1;
n1,n2,Amax:integer;
Далее идет наша программа.
Задания.
(Внимание! Есть некоторые отличия от задач из системы Moodle)
Задание 1 (Задание 4 из 1-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его случайными числами от -
10 до 10. Вывести его на экран. Найти максимальный элемент массива и вывести его на
экран.
Задание 2 (Задание 5 из 1-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его случайными числами в
диапазоне от n1 до n2 (n1 и n2 вводятся с клавиатуры). Вывести его на экран. Найти
номер минимального элемента массива и вывести его на экран. Если таких элементов
несколько, то вывести любой из них.
Задание 3 (Задание 6 из 1-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его случайными числами в
диапазоне от n1 до n2 (n1 и n2 вводятся с клавиатуры). Вывести его на экран. На место
максимального элемента массива записать число 9999 получившийся массив вывести
на экран. Если максимальных элементов несколько, то все их заменить на 9999.
Задание 4 (Задание 7 из 1-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его случайными числами в
диапазоне от n1 до n2 (n1 и n2 вводятся с клавиатуры). Вывести его на экран. Поменять
местами максимальный и минимальный элементы. Получившийся массив вывести на
экран. Если максимальных или минимальных элементов несколько, то выбрать любые
из них.
Задание 5 (Задание 6 из 2-ого занятия из Moodle)
Имеется массив целых чисел размером 2*N. Заполнить его числами, введёнными с
клавиатуры. Вывести его на экран. Поменять местами элементы, стоящие на чётных и
нечётных местах. Получившийся массив вывести на экран.
Задание 6* (Задание 2 из 2-ого занятия из Moodle)
Имеется массив целых чисел размером N. Заполнить его случайными числами в
диапазоне от n1 до n2 (n1 и n2 вводятся с клавиатуры). Вывести его на экран. Во второй
массив переписать те числа, которые делятся на 4 без остатка. Получившийся массив
вывести на экран."""
doc_4_double_array = """
Двухмерные массивы
Массив – упорядоченная совокупность элементов одного типа, занимающая
непрерывную область в памяти компьютера, имеющих одно имя и разные индексы. Все
элементы любых массивов следуют (занимают ячейки памяти) друг за другом.
1 элемент 2 элемент 3 элемент … N элемент
При работе просто с последовательностью данных (числами, строками или
другими типами данных) мы используем одномерный массив.
(По сути все массивы можно рассматривать как одномерные. Другое
представление массива, такое как двухмерные массивы и т.д. необходимо только для
удобства представления данных, для удобства решения задач). Элементы двухмерных
массивов имеют 2 индекса, N-мерных – N индексов.
При решении задач, требующих табличной организации данных, удобнее
использовать двухмерный массив.
Например, исходные данные необходимо представить (а также выполнить
различные действия с ними) в виде 3-х столбцов по 5 строк в каждом.
1 столбец 2 столбец 3 столбец
1эл. 2эл. 3эл. 4эл. 5эл. 6эл. 7эл. 8эл. 9эл. 10эл. 11эл. 12эл. 13эл. 14эл. 15эл.
все элементы
Как видно мы получили массив, состоящий из трех столбцов, каждый из которых в
свою очередь состоит из 5 строк. То есть, можно сказать, что мы получили массив
массивов.
Очевидно, что в этом случае, массив столбцов может быть выведен на экран
следующим образом:
1 столбец 2 столбец 3 столбец
1 строка 1 эл. 6 эл. 11 эл.
2 строка 2 эл. 7 эл. 12 эл.
3 строка 3 эл. 8 эл. 13 эл.
4 строка 4 эл. 9 эл. 14 эл.
5 строка 5 эл. 10 эл. 15 эл.
Опишем массив
Сначала опишем массив столбцов, который нам нужен
Const
 m=3;
Type
 masStolb=array[1..m] of masStrok;
Добавим описание массива строк
Const
 m=3;
 n=5;
Type
 masStrok=array[1..n] of integer;
 masStolb=array[1..m] of masStrok;
Разберём ещё один пример, в котором исходные данные необходимо представить
(а также выполнить различные действия с ними) в виде 3-х строк по 5 столбцов в
каждой.
1 строка 2 строка 3 строка
1эл. 2эл. 3эл. 4эл. 5эл. 6эл. 7эл. 8эл. 9эл. 10эл. 11эл. 12эл. 13эл. 14эл. 15эл.
все элементы
Как видно мы получили массив, состоящий из трех строк, каждый из которых в
свою очередь состоит из пяти столбцов. То есть, можно сказать, что мы получили
массив массивов.
Очевидно, что в этом случае, массив строк может быть выведен на экран
следующим образом:
1 столбец 2 столбец 3 столбец 4 столбец 5 столбец
1 строка 1 эл. 2 эл. 3 эл. 4 эл. 5 эл.
2 строка 6 эл. 7 эл. 8 эл. 9 эл. 10 эл.
3 строка 11 эл. 12 эл. 13 эл. 14 эл. 15 эл.
Опишем массив
Сначала опишем массив строк, который нам нужен
Const
 n=3;
Type
 masStrok=array[1..n] of masStolb;
Добавим описание массива столбцов
Const
 n=3;
 m=5;
Type
 masStolb =array[1..m] of integer;
 masStrok =array[1..n] of masStolb;
Как видно из этих примеров, двухмерный (в общем случае N-мерный) массив
можно представить как массив массивов. Причем двухмерный массив – это массив
строк (строка – одномерный массив) или массив столбцов (столбец – одномерный
массив).
Обращаться к элементам массива (например, с именем A) будем следующим
образом
A[1][4] или A[3][5] или A[ i ][ j ] ,
где i – это текущий номер элемента двухмерного массива, а j – текущий номер
элемента одномерного, составляющего двухмерный.
В качестве примера рассмотрим следующую задачу.
Заполнить двухмерный массив, как массив, состоящий из M столбцов по N
элементов в каждом, случайными числами от -10 до 10. Вывести его на экран.
Сначала опишем массив.
const
 n=3;
 m=6;
type
 mas1=array[1..n] of integer;
 mas2=array[1..m] of mas1;
Теперь напишем алгоритм решения задачи.
var
 C:mas2;
begin
 Zapol(c);//Заполнить массив C, состоящий из М столбцов и N строк
 Vyvod(c);//Выведем массив C на экран
end;
А теперь опишем необходимые нам процедуры. Опишем процедуру заполнения
массива столбцов.
procedure Zapol(var mas:mas2);
 var i:integer;
 begin
 for i:=1 to m do //Для I принимающего значения от 1 до M
 ZapSt(mas[i]); //Заполним столбец i-ый массива
 end;
Опишем, как заполняется один столбец, состоящий из N элементов (строк)
случайными числами в диапазоне от -10 до 10.
procedure ZapSt(var ma1:mas1);
 var
 j:integer;
 begin
 for j:=1 to n do // Для j принимающего значения от 1 до n
 ma1[j]:=Random(21)-10; //Элементу массива с номером j присвоим
 случайное значение из диапазона от -10 до +10
 end;
Опишем процедуру вывода полученного массива на экран.
procedure vyvod(mas:mas2);
 var
 i,j:integer;
begin
 for j:=1 to m do
 begin
 for i:=1 to n do
 write(mas[i][j]:4);
 writeln;
 end
end;
Посмотрим, что изменится, если нам нужно вывести массив построчно, т.е. как бы
перевернуть каждый столбец на 90 градусов. Тогда у нас будет 3 строки по 6
элементов в каждой.
Процедура вывода будет выглядеть следующим образом.
procedure vyvod(mas:mas2);
 var
 i,j:integer;
begin
 for i:=1 to n do
 begin
 for j:=1 to m do
 writeln(mas[i][j]:4);
 writeln
 end
end;"""
doc_5_string_to_int = """
Строки. Работа с численной информацией
Процедура VAL (st, x, code) преобразует строку символов st во внутреннее
представление целой или вещественной переменной Х, которое определяется типом этой
переменной.
Параметр code (тип integer) содержит ноль, если преобразование прошло успешно, и
тогда в Х помещается результат преобразования, в противном случае он содержит номер
позиции в строке st , где обнаружен ошибочный символ, и в этом случае содержимое Х не
меняется.
В строке st могут быть ведущие и/или ведомые пробелы. Если содержит символьное
представление вещественного числа, разделителем целой и дробной части должна быть
точка.
Пример:
Для проверки ввода чисел X и Y с клавиатуры используем процедуру VAL.
Если в переменные sx sy введены числа, то переменные cx и cy примут значение 0,
если нет, то отличные от 0.
VAL (sx, x, cx);
VAL (sy, y, cy);
If (cx=0) and (cy=0) then
Begin
 <операторы>
End
Еlse
 <операторы>
Процедура STR (x [:Width [: Decimal] ], st) преобразует число Х любого
вещественного или целого типов в строку символов st; параметры Width и Decimal, если
они присутствуют, задают формат преобразования.
Width определяет общую ширину поля, выделенного под соответствующее
символьное представление числа Х, а Decimal – количество символов в дробной части
(этот параметр имеет смысл только в том случае, когда Х – вещественное число).
Пример:
var
 x:integer;
y:real;
s:string;
begin
y:=3.5;
Str(y,s);
writeln(s);
readln
end;
Получим 3.500000000000000Е+0000
Однако, если записать преобразование следующим образом str(y:6:2, s);
Получим ںں3.50
отсутствующие позиции целой части заменяются пробелами (знак ں мы использовали
для обозначения пробела)
Если str(12345.6:5:2, s).
В этом случае целая часть числа выводится целиком, т.е. ограничение игнорируется.
Получим 12345.6
Если str(12.3456:5:2, s).
В этом случае дробная часть числа округляется до указанного знака после запятой.
Получим 12.35"""
doc_6_lazarus_start = """Знакомство с LCL. Простые компоненты.
Развитие персональных компьютеров привело к внедрению многозадачных,
многопользовательских систем. Например, операционная система Windows.
Наряду с этим создание нового программного обеспечения стало существенно
сложнее. Для облегчения работы по взаимодействию с операционной системой,
сокращения сроков написания программ и повышения качества программ были
разработаны визуальные среды, являющиеся системами быстрой разработки
приложений.
Визуальное программирование представляет собой процесс создания
приложений, при котором можно одновременно конструировать, изменять,
отлаживать приложение, используя интегрированную среду разработки. Иначе
говоря, визуальное программирование – это единство двух взаимосвязанных
процессов: наглядного конструирования типового окна приложения и написания
кода программы.
В основе идеологии Lazarus лежат технологии визуального проектирования и
событийного программирования, применение которых позволяет существенно
сократить время разработки и процесс созданий приложений.
Технология визуального проектирования позволяет пользователю
оформлять будущую программу (приложение) и видеть результаты своей работы
еще до запуска самой программы. А также, например, для задания каких-нибудь
свойств элементу разрабатываемого приложения не обязательно писать
массивные строки программы, достаточно изменений свойство в нужном окне. Это
изменение автоматически дополнит или модифицирует код программы.
При выборе нового проекта выберите строку Приложение в следующем окне
Откроются сразу несколько окон.
Главное окно, содержащее много вспомогательных окон.
Окно Инспектора объектов
Окно Конструктора формы (Form1)
Окно Редактора исходного кода.
Окно Сообщений
При любых действиях программиста в каком-либо из окон Lazarus
автоматически вносит изменения в код программы.
Главное окно Lazarus содержит главное меню, пиктографическое меню и
палитру компонентов.
Главное меню содержит все необходимые средства для управления
проектом.
Пиктографическое меню содержит кнопки быстрого доступа к наиболее
часто вызываемым опциям главного меню.
Например, для того, чтобы запустить программу на выполнение мы должны
выбрать в главном меню опцию Запуск – Запустить, или нажать клавишу F9, или
выбрать в пиктографическом меню зеленый треугольник.
Lazarus – среда объектно-ориентированного программирования. Под
объектом понимается целостный, неделимый элемент, имеющий свои свойства
(характеристики или отличительные признаки) и варианты действий.
Сформированный объект можно переносить из программы в программу. В Lazarus
включены сотни готовых объектов, которые представлены в Палитре
компонентов. Эти объекты (компоненты) сгруппированы по вкладкам).
К числу основных вкладок Палитры компонентов можно отнести следующие:
1. Standart (Стандартная)
2. Additional (Дополнительная)
3. System (Доступ к системным функциям)
4. Data Access (Работа с информацией из баз данных)
5. Data Cоntrols (Создание элементов управления данными)
6. Dialogs (Создание стандартных диалоговых окон)
Пока мы будем работать с вкладкой Standart в палитре компонентов, в
которой сосредоточены стандартные интерфейсные элементы, без которых не
может обойтись практически ни одна программа.
Окно формы – проект будущего приложения. Как правило, визуальное
программирование сводится к выбору нужного компонента и размещению его на
поле формы.
Lazarus при запуске автоматически предлагает пользователю новый проект
(так называется в Lazarus разрабатываемое приложение), открывая при этом
пустое (незаполненное) окно (форму) под названием Form1. Конечно, данная
форма содержит основные элементы окна Windows: заголовок Form1, кнопки
минимизации и закрытия окна, изменения размеров окна и кнопку вызова
системного меню окна. Это основное окно нашей программы. На него мы будем
переносить элементы из Палитры компонентов.
В Lazarus поля ввода (редактирования), командные кнопки и прочие
элементы управления, находящиеся на форме называются компонентами
(компонентами формы). В программе форма и компоненты рассматриваются как
объекты. Этим можно объяснить, что окно, в котором находятся свойства
компонентов, называется Инспектор объектов.
Окно Инспектора объектов содержит четыре вкладки. На первой Свойства
постоянно отображаются все доступные свойства выбранного компонента. В
левой колонке содержится список, в правой – текущие значения по умолчанию. На
второй вкладке, События, возможные обработчики событий для выбранного
компонента. В левой колонке – названия, в правой – соответствующие свойства
или процедуры. Остальные вкладки (Избранное, Ограничения) мы рассматривать
не будем.
Кнопка
(TButton)
Надпись
(TLabel)
Поле ввода
(TEdit)
В верхней части Инспектора объектов отображаются в виде дерева все
объекты (компоненты), которые мы размещаем на форме.
Окно редактора исходного кода служит для размещения кода программы.
В общем случае это окно обычно закрыто окном формы. Чтобы перемещаться из
окна кода программы в окно формы и обратно используется клавиша F12.
Завершение работы приложения
Нажатие кнопки закрытия экрана
Меню Запуск - Команда Остановить (Ctrl+F2)
Сохранение проекта
Любая программа Lazarus состоит из большого количества различных
файлов - это файл проекта, одного или нескольких модулей и т.д. Файл проекта
формируется автоматически средой Lazarus и не предназначен для
редактирования. Поэтому он имеет свое расширение (*.lpr) и не отображается в
окне кода программы. Модули – это коды программы. Каждый проект есть смысл
сохранять в отдельную папку.
Сохранять проект надо с помощью команды Сохранить все.
Необходимо создать новую папку под текущее занятие.
В новой папке под каждую задачу (проект) тоже создавать новую папку.
Папке и файлам проекта дать соответствующие имена. Не нужно
соглашаться с именами по умолчанию. Имена файлов состоят из английских букв,
цифры допустимы со второго символа. Остальные символы недопустимы.
Файлам Project1.lpr и Unit1.pas нужно будет дать свои имена (они разные),
остальным файлам имена будут присвоены по умолчанию.
При переименовании файлов Project1.lpr и Unit1.pas надо следовать
стандарту стилевого оформления исходного кода LAZARUS, согласно которому
все файлы должны иметь префикс ХХХ, например prjMyTask1.dpr и
untMyTask1.pas. (ХХХ – это буквы, соответствующие сокращенному названию
того, что Вы сохраняете: Project1 - prj и Unit1 - unt). Данное правило должно
использоваться и для переименования простых компонентов.
А теперь поговорим о некоторых простых компонентах, которые есть в среде
Lazarus.
Рассматриваемые компоненты считаются простыми не потому, что их легче
использовать, чем другие, а потому, что при создании графического интерфейса
они часто применяются в довольно сложных сочетаниях с другими компонентами.
Здесь рассматриваются следующие простые компоненты: форма, надпись, поле
ввода и кнопка.
Форма
Из перечисленных компонентов только форма является объектом,
отсутствующим на палитре компонентов. Чтобы добавить новую форму в проект
нужно выбрать команду Файл=>Создать форму или щелкнуть кнопкой мыши на
пиктограмме Создать форму на панели Пиктографическое меню. Работая в
Lazarus, представьте себе, что вы художник, а форма — это ваш холст. Вы
рисуете пользовательский интерфейс приложения путем размещения на форме
компонентов. Затем, изменяя свойства компонентов, вы изменяете их внешний
вид. После этого вы разрабатываете средства взаимодействия компонентов с
пользователем. Взаимодействие компонентов формы с пользователем означает
некоторую реакцию компонентов на действия пользователя.
Свойства компонентов – это их характеристики, например, имя, заголовок,
размер или цвет компонента, размер или цвет надписи на компоненте и т.д.
Рассмотрим три оставшихся простых компонента, которые находятся во
вкладке Standard (Стандартная) палитры компонентов.
Надпись
Компонент надпись (TLabel) используется для вывода на форму текста,
который пользователь не может изменить непосредственно (естественно, в
программе может быть предусмотрено изменение надписи "изнутри" программы).
Рассмотрим методику работы с надписями на конкретном примере. Выполните
ряд действий.
1. Создайте новый проект.
2. Поместите надпись на форму. Для этого дважды щелкните кнопкой мыши на
пиктограмме надписи на палитре компонентов. Другой способ размещения
надписи на форме — однократно щелкнуть кнопкой мыши на пиктограмме
надписи на палитре компонентов, а затем однократно щелкнуть в
произвольном месте формы. Такой способ удобен тем, что надпись в этом
случае размещается там, где вы хотите. Чтобы удалить надпись с формы,
нужно выделить ее (щелкнуть на ней кнопкой мыши, при этом она выделяется
черными квадратиками) и нажать клавишу <Delete>. Чтобы отменить
выделение, нужно щелкнуть кнопкой мыши в любом месте за пределами
надписи. Поэкспериментируйте с размещением и удалением надписей.
3. Переместите надпись в другое место на форме методом перетаскивания. Для
этого установите указатель мыши на надписи, нажмите кнопку мыши и,
удерживая ее нажатой, передвиньте надпись в другое место. Когда надпись
займет нужное положение, отпустите кнопку мыши.
4. Измените свойство надписи Name (имя надписи) на IblMyLabel (по умолчанию
она называлась Label1). Для этого в инспекторе объектов щелкните на
свойстве Name и введите IblMyLabel. Убедитесь, что вы изменяете свойство
надписи, а не формы (это типичная ошибка новичков). Для этого надпись на
форме должна быть выделена, а в заголовке раскрывающегося списка в
верхней части инспектора объектов должно быть написано Label1: TLabel
(когда вы измените имя надписи, там будет написано IblMyLabel: TLabel).
После ввода нужного имени надписи, зафиксируйте его, нажав клавишу
<Enter>.
5. Обратите внимание: заголовок надписи изменился на IblMyLabel. Это
объясняется тем, что по умолчанию заголовок надписи совпадает с ее именем.
Измените заголовок явно. Для этого выберите в инспекторе объектов свойство
Caption (заголовок надписи), введите новый заголовок «Это моя первая
надпись!» и нажмите клавишу <Enter>. Введенный текст должен появиться на
форме.
6. Измените цвет фона надписи. Для этого выберите свойство Color (цвет фона),
щелкните на стрелке, выберите в раскрывшемся списке желтый цвет и
щелкните на нем.
7. Измените шрифт и цвет текста надписи. Для этого выберите свойство Font
(шрифт) и щелкните на трех точках. В окне Font измените шрифт на Arial, стиль
на Bold Italic (полужирный курсив), а размер — на 20. В раскрывающемся
списке выберите красный цвет и щелкните на кнопке ОК.
8. Добавьте на форму еще одну надпись. На этот раз воспользуйтесь другим
методом — щелкните на пиктограмме надписи на палитре компонентов,
переместите указатель мыши в произвольное место формы и еще раз
щелкните кнопкой мыши. При этом на форме в указанном вами месте должна
появиться новая надпись.
9. Измените свойство Name новой надписи на IblAnother, а свойство Caption —
на «Другая надпись».
10.Теперь выделите форму. Это можно сделать двумя способами: щелкнуть в
любом месте формы за пределами надписей или выбрать Form1 в дереве
объектов в верхней части инспектора объектов. Если форма видна, то первый
способ, конечно, удобнее, однако если в проекте есть много форм, причем
нужная форма закрыта другими окнами, то более удобен второй способ.
11.Измените свойства формы: свойству Name задайте значение
frmLabelExample, a свойству Caption — «Пример надписи».
12.Итак, сами того не заметив, вы создали простое приложение, которое, правда,
пока что ничего не делает. Выполните его. Это можно сделать одним из трех
способов: щелкнув на пиктограмме Запустить (Зеленый треугольник),
выбрав в главном меню команду Запуск=> Запустить или нажав клавишу
<F9>.
13.Щелкнув на крестике в верхнем правом углу формы, завершите приложение.
Это же можно сделать и в среде Lazarus. Для этого запустите приложение еще
раз, активизируйте любое окно Lazarus (однократно щелкнув на нем кнопкой
мыши) и выберите Запуск=>Остановить или нажмите сочетание клавиш
<Ctrl+F2>.
Поле ввода
В компоненте поле ввода (TEdit) хранится текст, который можно помещать в
данный компонент как во время разработки, так и во время выполнения. Текст,
видимый в поле ввода, находится в свойстве Text. Свойство MaxLength
определяет максимальное количество символов в поле ввода. Если значение
свойства MaxLength равно 0, то количество символов ничем не ограничено. С
помощью свойства Font можно устанавливать шрифт текста. Если свойство
Readonly (только чтение) установить в True (истина), то во время выполнения
программы пользователь не сможет изменять текст поля ввода. Чтобы лучше
усвоить приемы работы с полями ввода, выполните ряд действий.
1. Создайте новый проект.
2. Разместите поле ввода на форме. Как и в случае надписи, это можно сделать
одним из двух способов: дважды щелкнуть на пиктограмме поля ввода на
палитре компонентов или щелкнуть на ней один раз, а затем щелкнуть в
произвольном месте формы.
3. Измените размер поля ввода. Для этого установите указатель мыши на одном
из черных квадратиков и, удерживая кнопку мыши нажатой, переместите
черный квадратик (а с ним и границу поля ввода) в нужном направлении.
Установив необходимый размер, отпустите кнопку мыши. (Если черных
квадратиков вокруг поля ввода нет, значит, оно не выделено. В этом случае
выделите поле ввода, щелкнув на нем кнопкой мыши.)
4. Переместите поле ввода в другое место методом перетаскивания. Для этого
установите указатель мыши на поле ввода, нажмите кнопку мыши и,
удерживая ее нажатой, передвиньте поле ввода в новое место. Когда поле
ввода займет нужное положение, отпустите кнопку мыши.
5. Установите значение свойства Name в edtMyText. Для этого в инспекторе
объектов щелкните на свойстве Name и введите edtMyText. Как и в случае с
надписью, убедитесь, что вы изменяете свойство поля ввода, а не формы. Для
этого в дереве объектов в верхней части инспектора объектов должно быть
написано Edit1: TEdit (после изменения свойства Name здесь будет написано
edtMyText: TEdit).
6. Выберите в инспекторе объектов свойство Text и введите его новое значение:
Это элемент управления "поле ввода". Нажав клавишу <Enter>, зафиксируйте
введенный текст. Обратите внимание: во время ввода изменяется текст в поле
ввода на форме.
7. Измените цвет текста в поле ввода на синий. Для этого в инспекторе объектов
щелкните на значке ► рядом со свойством Font. При этом значок ►
поворачивается на 45 градусов и появляется список свойств объекта Font.
Выберите свойство Color и щелкните на стрелке, расположенной в этом поле.
При этом раскрывается список доступных цветов. Найдите в нем синий цвет и
щелкните на нем.
8. Выделите форму. Это можно сделать одним из двух способов: щелкнув в
любом месте формы за пределами поля ввода или выбрав имя формы в
дереве объектов в верхней части инспектора объектов. Измените свойство
формы Name на frmEditBoxExample, а свойство Caption — на Пример поля
ввода.
9. Нажав клавишу <F9>, запустите разработанную программу на выполнение.
Поэкспериментируйте с полем ввода. Введите в него какой-либо текст.
10.Для завершения программы щелкните на крестике в правом верхнем углу
формы.
11.Установите значение свойства Readonly в True.
12.Нажав клавишу <F9>, запустите программу на выполнение еще раз.
Попытайтесь изменить содержимое поля ввода: как видите, теперь изменить
его содержимое во время выполнения нельзя. Возможно, вы удивитесь: зачем
может понадобиться поле ввода, в которое нельзя ничего ввести? Однако в
дальнейшем вы увидите, что это довольно полезное средство, так как
значение свойства Readonly можно менять из программы, запрещая или
разрешая таким образом пользователю вводить данные.
13.Щелкнув на крестике в правом верхнем углу формы, завершите выполнение
программы.
Кнопка
Обычно с помощью компонента кнопка (TButton) пользователь инициирует
выполнение какого-либо фрагмента кода или целой программы. Другими словами,
если щелкнуть на элементе управления TButton, то программа выполняет
определенное действие. При этом кнопка принимает такой вид, будто она
вдавлена.
Кнопкам можно присваивать комбинации клавиш быстрого вызова. Во время
выполнения нажатие такой комбинации клавиш эквивалентно щелчку на кнопке
левой кнопкой мыши. Выполните ряд действий,
1. Создайте новый проект.
2. В инспекторе объектов измените значение свойства формы Name на
frmButtonExample, а свойства Caption — на Пример кнопки.
3. Поместите кнопку на форму. Для этого дважды щелкните на пиктограмме
кнопки на палитре компонентов или однократно щелкните на ее пиктограмме, а
затем в любом месте формы.
4. Измените значение свойства Name кнопки на btnMyButton. Для этого в
инспекторе объектов щелкните на свойстве Name и введите btnMyButton.
Убедитесь, что вы изменили свойство кнопки, а не формы. В дереве объектов
в верхней части инспектора объектов должно быть написано Button1: TButton,
а после изменения имени — btnMyButton: TButton.
5. Измените значение свойства Caption кнопки на &Run. Обратите внимание: в
заголовке кнопки буква, перед которой стоит символ &, оказалась
подчеркнутой. В данном случае это буква R.
6. Измените размер и положение кнопки.
7. Нажав клавишу <F9>, запустите программу на выполнение.
8. Щелкните на кнопке. При этом кнопка принимает такой вид, будто она
"вдавлена".
9. Активизируйте кнопку, нажав клавишу <R>. Как видите, при активизации
клавишами быстрого вызова кнопка не принимает вид вдавленной. Пока еще с
кнопкой не связан какой-либо фрагмент кода, поэтому никакой реакции кнопки
не видно. Тем не менее, можете поверить, она активизируется.
10.Щелкнув на крестике в правом верхнем углу формы, завершите работу
программы.
Заголовок кнопки btnMyButton выглядит как Run, а не Run. Символ &,
расположенный перед любой буквой значения свойства Caption, присваивает
кнопке комбинацию клавиш быстрого вызова. В заголовке кнопки буква, перед
которой стоит символ & подчеркнута. Это сообщает пользователю о том, что с
кнопкой связана клавиша быстрого вызова. Во время выполнения пользователь
может активизировать кнопку с помощью клавиатуры. Для этого нужно нажать
клавишу с подчеркнутой буквой.
В данном примере клавиатура должна быть переключена на английский язык
(С русскими буквами работать не будет).
Что делать, если в заголовке кнопки должен присутствовать символ &? Ведь
если поместить его в заголовок, то он сделает следующую букву подчеркнутой, а
сам виден не будет. Чтобы решить эту проблему, используется следующее
правило: символ & отображается в заголовке кнопки, если в свойстве Caption
записаны два стоящих подряд символа — &&. Например, чтобы заголовок кнопки
имел вид This & That, в свойстве Caption должно быть написано This && That. При
этом никакая комбинация клавиш быстрого вызова кнопке не присваивается.
Как видите, с помощью среды разработки Lazarus можно буквально за
минуту создать простую форму (и программу). Аналогично создаются также самые
сложные пользовательские интерфейсы. Теперь вы знакомы со свойствами
некоторых наиболее распространенных компонентов Lazarus — формами,
надписями, полями ввода, областями просмотра и кнопками. Чтобы закрепить
полученные знания, поэкспериментируйте с этими компонентами. Попробуйте
изменять другие их свойства."""
doc_7_code_review = """
Руководство по оформлению кода
Однажды Гарольд Абельсон, человек уважаемый в мире компьютерных наук,
сказал:
“ПРОГРАММЫ ДОЛЖНЫ ПИСАТЬСЯ ДЛЯ ТОГО,
ЧТОБЫ ИХ ЧИТАЛИ ЛЮДИ, А ВЫПОЛНИМОСТЬ
ЭТИХ ПРОГРАММ МАШИНАМИ — ПОБОЧНЫЙ
ЭФФЕКТ”.
Конечно, это шутка, но … Предположим, Ваша программа работает, но код
оформлен плохо. Коллеги в таком коде разбираться не будут, через месяц и Вы в
нем ничего не поймете. Программа всегда требует доработки, у Вас же она
получается одноразовой. Смысл?
Короче, Вы уже поняли: оформление программного кода должно быть
стандартизировано. Этим мы сейчас и займемся.
Основные принципы
1. Если операторы выполняются один за другим, они пишутся один под
другим.
2. Если один оператор управляется другим, то он пишется на следующей
строке с отступом внутрь управляющего оператора.
Пробелы, отступы и шрифт
Шрифт для написания кода надо выбирать моноширинный (все символы
одной ширины). Для этого в Lazarus:
Главное меню → Сервис → Параметры → Редактор → Отображение →
Шрифт редактора по умолчанию → Courier New / Courier → ОК.
Межстрочный интервал лучше делать равным единице.
Договоримся использовать отступы в 4 пробела. Для этого надо научить свой
редактор вставлять 4 пробела при нажатии клавиши табуляции. Для этого в
Lazarus:
Главное меню → Сервис → Параметры → Редактор → Общие → Табуляция и
отступ → Преобразование Tab в пробелы → 4 → ОК.
Иногда требуется увеличить или уменьшить отступ у целого блока
программы. Для этого в Lazarus:
Главное меню → Сервис → Параметры → Редактор → Общие → Табуляция и
отступ → Отступ блока Ctrl+I / Ctrl+U → Отступ блока в пробелах → 4 → ОК.
Ставьте пробелы после запятых, двоеточий и точек с запятой (формальные
параметры в подпрограммах) так, как это делается в книгопечатании.
Ставьте пробелы вокруг бинарных операций.
Между блоками описаний (константы, типы, подпрограммы, переменные) и
перед выполнимой частью программы вставляйте пустую строку (“вертикальный
пробел”).
Когда строка становится длиннее 80 символов, разделите её на две, сделав
перевод на новую строку после оператора, и продолжайте писать.
Ниже приведены примеры на тему «что такое хорошо и что такое плохо».
Пример 1. Отступы и пробелы
Пример 2. Условный оператор
// хорошо :)
if x1 < x2 then
 delete(f, p1+1, p2-p1)
else
 if x1 > x2 then
 begin
 x1 := x2;
 delete(f, 1, p1)
 end
 else
 p1 := 0;
Пример 5. Длинная строка – хороший вариант
Пример 3. Цикл и условный оператор
Пример 4. Цикл с составным оператором
// хорошо :)
for i:=1 to 3 do
 begin
 readLn(s);
 dve(s, f, rost);
 end.
Названия и переменные
Давайте переменным содержательные имена, такие как firstName или
homeWork. Избегайте однобуквенных названий вроде x или c, за исключением
счётчиков вроде i, j, k и т.д.
Называйте переменные и подпрограммы, используя верблюжийРегистр
(Camelcase ), а константы — в ВЕРХНЕМ_РЕГИСТРЕ.
Давайте свои имена компонентам Lazarus, используя префиксы:
Компонента Стандартные имена
компонент
Префикс Примеры Ваших имен
компонент
Кнопка Button1, Button2, … btn btnStart, btnPaint
Поле ввода Edit1, Edit2, … edt edtPointX, edtKolSides
Поле надписи Label1, Label2, … lbl lblPointX, lblKolSides
Если определённая константа часто используется в вашем коде, то
обозначьте её как const и всегда ссылайтесь на данную константу, а не на её
значение:
Выбирайте подходящий тип данных для ваших переменных. Если переменная
содержит лишь целые числа, то определяйте её как longint, а не real.
Никогда не объявляйте глобальную переменную в области видимости всех
подпрограмм. Сверху можно объявлять только константы и типы.
Теперь Ваши программы, особенно если они будут
правильно работать, станут идеальными! ☺
P.S.  Несоблюдение правил карается:
1. Отказом помогать в поиске ошибок.
2. Снижением оценки.
"""
doc_8_button = """
Обработка события нажатия на кнопку
Визуальные компоненты способны генерировать и обрабатывать достаточно большое
число (несколько десятков) событий различного вида: щелчок мыши, нажатие на кнопку,
нажатие клавиш клавиатуры, открытие окна.
Когда пользователь нажимает на любую кнопку, Windows посылает сообщение
приложению: «По такой-то кнопке щёлкнули». Если пользователь использовал это
сообщение и написал реакцию на него, то программа выполнит это.
Реакции на событие - это результат произошедшего системного события.
Реакцию на событие назначают программно, указывая список действий, которые
необходимо произвести, в окне редактора исходного кода.
(Чтобы заставить программу реагировать на щелчок, необходимо написать фрагмент
программы, который называется обработчиком события).
Окно редактора исходного кода.
На момент запуска окно имеет заголовок Unit1.
В редакторе кода могут быть открыты сразу несколько файлов. Каждый открытый файл
размещается на отдельной странице, а его название отображается в верхней части (на
вкладке). Если в программе будут три окна, то они в процессе работы будут
взаимодействовать с тремя модулями (Unit). Все эти модули и отображаются в редакторе
кода.
Простые события содержат только источник события, на который указывает параметр
Sender в Процедуре обработки события. В сложных событиях в Процедуре обработки
события требуются дополнительные параметры (например, передача координат указателя
мыши).
При выборе управляющего элемента возникает событие OnClick, которое также
называют Событие нажатия. Обычно оно возникает при щелчке мышью на компоненте. При
разработке приложений событие OnClick является одним из наиболее часто используемых.
(Для некоторых компонентов событие OnClick может возникать и при других способах
нажатия на управляющий элемент).
В качестве примера напишем реакцию нажатия на командную кнопку btnMy
расположенную на форме frmMy.
Дважды щелкаем по этой кнопке.
Lazarus автоматически подготавливает редактор кода для минимизации ввода данных с
клавиатуры, набирая за нас заголовок процедуры реакции нажатия на кнопку.
procedure TfrmMy.btnMyClick(Sender: TObject);
begin
end;
Курсор будет находиться между словами begin и end. Именно здесь мы и напишем
команду программного закрытия окна формы (аналогично действию системной кнопки в
заголовке этого окна). Поскольку это окно единственное и главное, то будет закрыта и вся
программа.
Набираем вручную frmMy и ставим точку. Через несколько секунд Lazarus выводит для
нас дополнение кода. Это список доступных свойств и методов для объекта frmMy.
Обратим внимание на то, что дополнение кода помогает в наборе и указывает на
существующую процедуру, выбрав в списке слово Close. Завершение ввода из списка
дополнения кода осуществляется нажатием на клавишу Enter.
Окончательно наше описание реакции нажатия на командную кнопку btnMy выглядит
следующим образом:
procedure TfrmMy.btnMyClick(Sender: TObject);
begin
frmMy.Close;
end;
Если нажать на командную кнопку btnMy после запуска работы программы, то окно
формы закроется. В данном примере мы использовали метод (процедуру) Close. Метод
показывает, что необходимо сделать с объектом. Из примера видно, что формат обращения
к методу следующий: сначала идёт имя объекта (свойство Name), затем ставится
разделитель – точка, и после разделителя имя метода, т.е. что необходимо сделать с
объектом.
<Имя_объекта>.<Метод>;
Как мы уже говорили объекты имеют не только методы, но и свойства. Свойства - это
характеристики объектов. Свойство можно изменить или задать следующим образом:
сначала указывается имя объекта, потом ставится разделитель – точка, после неё ставиться
имя свойства, причём система даёт нам возможность выбрать необходимое нам свойство из
меню, потом ставится значок присваивания и далее значение свойства.
<Имя_объекта>.<Свойство>:=<Значение>;
Свойства, так же как и переменные имеют тип. Например, свойства Caption и Text имеют
тип String.
Давайте теперь напишем программу, в которой при нажатии на командную кнопку окно
формы закрасится белым цветом. В данной программе необходимо использовать свойство
Color.
procedure TfrmMy.btnMyClick(Sender: TObject);
begin
frmMy.Сolor:=clWhite;
end;
Свойства объектов можно не только задавать, но и считывать. Формат записи выглядит
следующим образом:
<Переменная>:=<Имя_объекта>.<Свойство>;
Переменная должна иметь тот же тип, что и свойство объекта. Таким же образом можно
через свойство одного объекта задавать свойства другого. Например:
lblMy.Caption:=edtMy.Text;
По данному предложению текст окна ввода edtMy будет помещён на заголовок надписи
lblMy.
Переменные и их типы. Преобразование типов
В Lazarus, также как и в Pascal для решения различных задач можно использовать
переменные. Для этого их нужно описать в блоке объявления (Implementation) после
служебного слова Var (переменная). Формат описания переменных следующий:
Var
<имя переменной>: <тип переменной>;
Имя переменной представляет собой последовательность символов, составленную по
следующим правилам:
• в имени используются только латинские буквы, либо цифры (от 0 до 9), либо значок
подчёркивания;
• первый символ в имени может быть только буквой;
• количество символов в имени не ограничено.
Различия между заглавными и прописными буквами не существует.
Когда Вы раздумываете над именами переменных, то имейте в виду, что нужно избегать
однобуквенных имён, кроме как для временных переменных и переменных цикла.
Переменные цикла именуются I и J. Другие случаи использования однобуквенных
переменных это S (строка) и R (радиус). Однобуквенные имена должны всегда использовать
символ в верхнем регистре, но лучше использовать более значимые имена. Не
рекомендуется использовать переменную l (эль), потому что она похожа на 1 (единица).
Типов переменных в среде Lazarus очень много. Рассмотрим только некоторые из них.
Целые числа могут быть описаны несколькими типами, представленными в таблице.
Название типа Диапазон изменения чисел Формат представления в
компьютере
Integer От -2147483648 до 2147483647 32-bit, число со знаком
Cardinal От 0 до 4294967295 32-bit, положительные числа
ShortInt От -128 до 127 8-bit, число со знаком
SmallInt От -32768 до 32767 16-bit, число со знаком
LongInt От -2147483648 до 2147483647 32-bit, число со знаком
Int64 От -2
63 до 2
63
-1 64-bit, число со знаком
Byte От 0 до 255 8-bit беззнаковый тип
Word От 0 до 65535 16-bit беззнаковый тип
LongWord От 0 до 4294967295 32-bit беззнаковый тип
Мы, как правило, будем пользоваться типом Integer.
Вещественные числа также могут быть представлены несколькими типами. Мы будем
пользоваться типом Real.
Название
типа
Диапазон изменения Кол-во
значащих цифр
Занимаемый
объем в байтах
Real48 От ±2.9 х 10-39
 до ±1.7 x 1038 11-12 6
Real От ±5.0 х 10-324
 до ±1.7 x 10308 15-16 8
Single От ±1.5 x 10-45
 до ±3.4 x 1038 7-8 4
Double От ±5.0 x 10-324 до ±1.7 x 10308 15-16 8
Extended От ±3.6 x 10-4951 до ±1.1 x 104932 19-20 10
Comp От -2
63
 до 263
-1 19-20 8
Currency От -922337203685477.5808
до +922337203685477.5807
19-20 8
Сделаем свой Первый проект Сумма двух чисел
Как это сделать?
1. Запустить Lazarus , закрыть текущий проект (если он был), создать новый проект ,
выбрав Приложение.
2. На форму поместить два окна ввода, три надписи и кнопку.
3. У формы и всех компонент изменить свойства.
4. У формы - Name, Color, Caption, у всех надписей - Name, Font, Caption, у полей
ввода - Name, Text, у кнопки - Name, Caption.
5. Имена полей ввода edtX, edtY, имена надписей lblX, lblY, lblSumma, имя формы
frmSumma, имя кнопки btnStart. Имена и свойства приведены в качестве примера.
6. Сохраним проект.
7. Запустим проект.
8. Мы спроектировали интерфейс программы, но наша программа еще не работает. Мы
хотим, чтобы в окнах ввода можно было задавать числа и выводить их сумму. Как это
сделать? Давайте разбираться.
9. Для того, чтобы выполнить нужные нам действия, нам нужно написать программный
код (на языке Паскаль) и определить каким образом он будет выполняться. Например,
по щелчку мыши на компонент btnStart (на кнопку).
Напишем реакцию нажатия на командную кнопку btnStart, расположенную на форме
frmSumma. Дважды щелкаем по этой кнопке.
Lazarus автоматически подготавливает редактор кода для минимизации ввода данных с
клавиатуры, набирая за нас заголовок процедуры реакции нажатия на кнопку.
Курсор будет находиться между словами begin и end. Именно здесь мы и напишем
программный код. Сначала напишем комментарии.
procedure TfrmSmma.btnStartClick(Sender: TObject);
begin
 // Ввести число X
 // Ввести число Y
 // Сложить два числа
 // Вывести ответ
end;
Значений переменных x и y будем брать из полей ввода edtX и edtY. При этом
необходимо помнить, что в поле ввода вводятся строки.
Для перевода строки в вещественное число существует функция StrToFloat(строка).
Для перевода строки в целое число существует функция StrToInt(строка).
Также есть и обратные функции перевода из вещественного или целого числа в строку
FloattoStr(число) и InttoStr(число).
procedure TfrmSmma.btnStartClick(Sender: TObject);
Var
 x, y, c: real;
begin
 x := StrToFloat(edtX.Text); // ввести число X
 y := StrToFloat(edtY.Text); // ввести число Y
 c := x + y; // сложить два числа
 lblSumma.Caption := lblSumma.Caption + FloatToStr(c); // вывести
ответ
end;
При работе с функциями StrToFloat и FloatToStr в среде Lazarus необходимо следить
за разделителем целой и дробной части. В программе (Unit) в качестве разделителя
используется только точка. А в окнах ввода на форме символ разделителя зависит от
настроек Windows. В русифицированных версиях в качестве разделителя целой и дробной
части числа используется запятая.
В нашем проекте осталось изменить свойства надписей и формы. Это можно сделать
вручную или программно. Для примера изменим программно свойства одной надписи, для
двух других аналогично
procedure TfrmSmma.btnStartClick(Sender: TObject);
var
 x, y, c: real;
begin
 frmSumma.color := clyellow; // цвет формы frmSumma желтый
 lblX.Font.Name := 'Arial'; // шрифт компонента lblX Arial
 lblX.Font.Size := 18; // размер шрифта компонента lblX 18
 lblX Font.Style := [fsBold]; // шрифт компонента lblX полужирный
 x := StrToFloat(edtX.Text); // ввести число X
 y := StrToFloat(edtY.Text); // ввести число Y
 c := x + y; // сложить два числа
 lblSumma.Caption := lblSumma.Caption + FloatToStr(c); // ответ
end;
Примеры использования различных свойств объектов
1. frmSumma.Сolor := clYellow Форма закрашивается
желтым цветом, который
является предопределенной
константой и начинается с
префикса cl – clWhite, clRed
2. lblX.Color := clGreen Фон компонента
закрашивается в зеленый
цвет
3 lblX.Font.Color := clBlack Цвет шрифта компонента
устанавливается черный
4 lblMy.Font.Size := 14 Размер шрифта компонента
устанавливается 14
5 lblY.Visible := false Компонент становится
невидимым, тип свойства
логический
6 lblY.Visible := not lblY.Visible Текущему значению свойства
присваивается предыдущее
значение с инверсией.
Компонент был видимый,
потом стал невидимым и т.д.
7 lblY.Caption := 'сумма =' На компоненте появится
надпись сумма =
тип свойства string
8 lblY.Caption := 'сумма=' + InttoStr(S) На компоненте появится
надпись сумма =125,
если значение переменной S
было 125
9 lblMy.Caption := edtMy.Text Текст окна ввода edtMy будет
помещён на компонент lblMy
10 edtMy.Text := '' Окно ввода становится
пустым"""
doc_9_graphic = """
Графика
Графика в Lazarus
Для того, чтобы работать с графикой в среде Lazarus существует много
возможностей. Рассмотрим некоторые из них. Рисунки будем помещать на
объекте PaintBox.
Выберем на палитре компонентов вкладку Additional (дополнительная). Мы
увидим пиктографическое меню для этой вкладки и выберем из него пиктограмму
TPaintBox. Растянув данный компонент на форме, мы получим место для
размещения рисунков, как будто мы изготовили раму для рисования картины, а
теперь на раму необходимо натянуть холст, полотно. Это мы будем делать при
помощи свойства Canvas (полотно). Начало координат нашего рисунка находится
в левом верхнем углу объекта, ось X направлении горизонтально слева направо,
а ость Y направлена сверху вниз. Размер рисунка можно посмотреть поставив
курсор на компонент PaintBox, или .используя свойства Height (высота) и Width
(ширина). Например, изменив свойство имя (Name) объекта PaintBox, например,
на pbxEx, определим центр компонента PaintBox
x0:= pbxEx.Width div 2;
y0:= pbxEx.Height div 2;
Для создания изображения на холсте нам надо иметь инструменты для
рисования. Также и в Lazarus рисовать на холсте можно с помощью пера,
закрашивать фигуры кистью, текст выводить с помощью свойства «шрифт».
Для изменения цвета и толщины линии любой фигуры (т.е. рисования
фигуры) используется объект Pen (перо).
pbxEx.Canvas.Pen.Color:=clRed;
pbxEx.Canvas.Pen.Width:=3;
После такого задания свойств «пера» фигуры будут нарисованы красным
цветом и чуть более толстой линией, чем по умолчанию.
Объект Brush (кисть) служит для заполнения внутреннего пространства
замкнутых фигур.
pbxEx.Canvas.Brush.Color:=clGreen;
Цвет кисти станет зеленым.
Рассмотрим, как установить цвет кисти белый и произвести заливку всей
рабочей области белым цветом.
pbxEx.Canvas.Brush.Color := clwhite;
pbxEx.Canvas.FillRect(ClientRect);
Стиль закраски и стиль линии можно тоже менять при помощи свойства
стиль. Формат обращения к этому свойству предлагаем найти самостоятельно.
Рассмотрим стандартные графические примитивы, которые мы можем
разместить на нашем холсте.
Точка.
Для окрашивания точки (X,Y) в определенный цвет используется следующее
свойство - точка. Cвойство Pixels[x,y] – задает цвет точки с координатами X,Y.
pbxEx.Canvas.Pixels[x,y]:=clRed;
То есть, пиксель с координатами (X,Y) закрашивается в данном случае
красным цветом. Обращаем ваше внимание на то, что квадратные скобки
используются только для окрашивания точки.
Линия.
Линия рисуется с помощью метода
pbxEx.Canvas.LineTo(X,Y)
Линия рисуется от текущего местоположения графического курсора в точку,
координаты которой указаны в скобках.
Перо (графический курсор) можно перемещать без прорисовки следа в точку
(X.Y) с помощью процедуры
pbxEx.Canvas.MoveTo(X,Y)
Любая фигура не перемещает графический курсор.
Прямоугольник.
Для рисования прямоугольника используется метод
pbxEx.Canvas.Rectangle(X1,Y1,X2,Y2)
Данная процедура рисует закрашенный прямоугольник со сторонами
параллельными экрану и с диагональю с координатами (X1,Y1,X2,Y2).
Граница прямоугольника по умолчанию черного цвета, а закраска белая.
Эллипс.
Задается прямоугольником, в который он вписывается. Оси эллипса
параллельны границам экрана. Эллипс рисуется закрашенным.
pbxEx.Canvas.Ellipse(X1,Y1,X2,Y2)
Задания.
Задание 1.
Нарисовать окружность, состоящую из N точек радиуса R с заданными
координатами центра Xc, Yc.
Все параметры вводятся в поле ввода.
Координаты точки, лежащей на окружности, определяются следующим
образом:
X = Xc + R cos(α)
Y = Yc - R sin(α)
Угол α меняется от 0 до 2π на величину 2π /n.
Задание 2.
Вводятся 3 числа – это длины отрезков. Если из этих отрезков можно
построить треугольник, то сделать это, если нельзя, то сообщить об этом.
Задание 3.
Нарисовать упрощённые часы (без цифр, но с черточками).
В поле ввода вводится время. По нажатию кнопки рисуются стрелки в
нужном положении."""
doc_10_graphic_text = """
Занятие 5
Вывод текста на графический компонент
Метод TextOut (X, Y:Integer, const Text:string) выводит текстовую строку
Text так, чтобы левый верхний угол прямоугольника, охватывающего текст,
располагался в точке (X, Y).
Рассмотрим, с помощью каких свойств можно менять вид шрифта текста
выводимого на графический компонент.
Свойства класса TFont
Высота шрифта в пунктах (1/72) дюйма - Size. Изменение этого свойства
автоматически изменяет свойство Height и наоборот
pbxEx.Canvas.Font.Size :=20
Высота шрифта в пикселах экрана - Height
pbxEx.Canvas.Font.Height :=24
Имя шрифта (по умолчанию MS Sans Serif) - Name
pbxEx.Canvas.Font.Name:=’TimesNewRoman’
Пример
Вывести в позицию (10,10) следующий текст 'ИЗУЧАЕМ LAZARUS'. Имя
шрифта=Arial, размер шрифта =10
pbxEx.Canvas.Font.Size :=10;
pbxEx.Canvas.Font.Name:='Arial';
pbxEx.Canvas.TextOut(50,50,’ ИЗУЧАЕМ LAZARUS’)
Задания.
Задание 1.
Переделать последнюю задачу из предыдущего занятия поставив на
циферблате часов цифры рядом с черточками.
Задание 2.
Нарисовать декартову систему координат, обозначив оси X, Y и сделать
разметку по осям. Максимальные и минимальные значения для X и Y и цена
деления для каждой оси вводятся в соответствующие поля ввода.
ПРИВЕТ"""
doc_11_memo = """
Компонент Memo
Компонент Memo – многострочное редактируемое текстовое поле.
Компонент Memo предназначен для ввода, редактирования и
отображения достаточно длинного многострочного текста.
С помощью различных свойств и методов можно динамически
формировать содержимое компонента Memo ( или поля Memo).
Свойства Font и Readonly поля Memo аналогичны этим же свойствам
поля ввода. Свойство Text содержит весь текст поля Memo, однако это
свойство доступно только по время выполнения.
При выводе в область просмотра текста на русском языке необходимо
учитывать, что не все шрифты оснащены кириллицей. Кроме того,
некириллической может оказаться текущая кодовая таблица. Если вместо
русского текста на экране появилась абракадабра, го нужно изменить
значение свойства Charset (Набор символов) объекта Font (Шрифт). Для
большинства шрифтов удовлетворительными значениями свойства
Charset являются DEFAULT_CHARSET или RUSSIAN_CHARSET.
Свойства
Свойство Lines
Текст компонента Memo хранится в свойстве Lines и представляет
собой пронумерованный набор строк (нумерация начинается с нуля) –
первая строка имеет индекс 0, вторая - индекс 1 и т.д.
Пример
Var
s : string;
Begin
s:= memEx.Lines[2]; // переменной s присваивается содержимое
 3-ей строки
memEx.Lines[3]:='Привет'; // строке с номером 4 присвоить
 строковую константу 'Привет'
…..
end;
Обращаться указанным способом к строкам поля Memo из программы
можно только, если строки уже ранее созданы либо через инспектор
объектов, либо введены с клавиатуры после запуска программы, либо
созданы соответствующим методом. Нельзя обратиться к
несуществующей строке.
С помощью свойства Lines можно заполнить поле Memo.
Для этого в инспекторе объектов надо нажать на кнопку с многоточием
в поле свойства Lines; откроется окно редактора строк. В окне редактора
строк можно вводить строки, заканчивая набор каждой строки нажатием
клавиши <Enter>.
После окончательного ввода строк, нажмите кнопку <OK>.
Свойство Count
Общее количество строк можно узнать с помощью свойства Count.
k:=memEx.Lines.Count;
Свойство Count имеет статус Read/Only, т.е. изменять
(редактировать) его нельзя.
Свойство WordWarp
Определяет, будут ли переноситься строки, выходящие за пределы
области просмотра или они останутся невидимыми.
Свойство MaxLength
Определяет максимальное количество символов во всем поле Memo.
Если значение свойства MaxLength равно 0, то количество символов
ничем не ограничено.
Свойство ScrollBars
Это свойство определяет наличие или отсутствие полос прокрутки.
При указании параметров - обе полосы или вертикальная, свойство
MaxLength игнорируется
Свойство Aligment(выравнивание)
Это свойство позволяет расположить текст в окне просмотра так, так
вам необходимо.
Методы
Рассмотрим некоторые методы работы с полем Memo.
Метод Delete.
Метод удаляет строку с указанным индексом, происходит
перенумерация строк (остальные строки автоматически сдвигаются).
memEx.Lines.Delete(0); // удаляет самую первую строку, т.е. строку c
индексом 0.
Пример 1.
Оставьте в поле Memo только нечетные строки.
k:=memEx.Lines.Count;
For i:=k-1 Downto 1 Do
if (i mod 2) <>0 then
 memEx.Lines.Delete(i);
Метод Exchange
Данный метод позволяет поменять местами строки с указанными
индексами.
memEx.Lines.Exchange(0,1); // меняет местами строки с индексом 0 и 1
Метод Move
Данный метод позволяет передвинуть строку с одного места на
другое.
Например
memEx.Lines.Move(1,5);
При выполнении этого метода строка с номером 1 (т.е. вторая в поле,
т.к. первая имеет номер 0) будет изъята из текста, все строки, которые
следуют за ней, будут подняты на одну строку вверх, и на место пятой
строки будет поставлена первая.
Задания.
Задание 1.
Заполнить поле Memo.
Написать программу, которая позволяет при нажатии на клавишу
оставить в поле
 только первые 4 строки, если строк больше 4-х
 1 строку, если строк не больше 4-х.
Задание 2.
Заполнить поле Memo и окно ввода.
Написать программу, которая позволяет при нажатии на клавишу
вывести в заголовок надписи
a) номер строки из поля Memo, которая соответствует строке в окне
ввода, или надпись, что аналогичных строк нет;
b) номера строк, которые содержат введенное в поле ввода сочетание
символов, или надпись, что строк с данным сочетанием символов
нет.
Задание 3.
Заполнить поле Memo текстом, состоящим из нескольких строк, таким
образом, чтобы в одной из строк было слово «cat», еще в одной – «dog».
Написать программу, которая позволяет поменять эти строки местами
Задание 4.
Заполнить поле Memo.
Написать программу, которая позволяет найти наиболее длинную
строку и поставить ее в начало.
Задание 5.
Заполнить поле Memo числами (по одному в каждой строке).
Написать программу, которая позволяет все четные числа увеличить в
два раза и перенести во второе поле Memo, а нечетные уменьшить в два
раза и перенести в третье поле Memo."""
doc_12_memo_2 = """1
Компонент Memo (продолжение)
Рассмотрим еще несколько свойств и методов, которые позволяют
работать с полем Memo.
Свойство Clear
Позволяет очистить полностью содержимое поля Memo.
memEx.Lines.Clear
Методы Append и Add
Если поле Memo пустое или было применено свойство Clear, то для
заполнения поля Memo можно использовать метод Append, который
добавляет новую строку в конец текста поля Memo.
Пример.
Заполнить поле Memo числами от 1 до 10 по одному на каждой
строке.
. . .
memEx.Lines.Clear;
For i:=1 to 10 do
begin
 memEx.Lines.Append (IntToStr(i));
end;
Аналогично работает и другой метод Add.
memEx.Lines.Add ('This example uses A string List.');
Как видно из примеров, в качестве параметров у этих методов
используются строки.
С помощью метода Add можно не только добавлять строки в поле
просмотра, но и узнать (и вывести, например) номер строки, в которую
произошло добавление строки с помощью метода Add.
b:=memEx1.Lines.Add(edtEx1.Text);
lblEx1.Caption:=IntToStr(b);
В данном примере, текст, который был введен в поле edtEx1, был
добавлен в поле memEx1, и в надпись lblEx1 был выведен номер строки, в
которую был добавлен текст.
Переносить, сохранять, восстанавливать фрагменты текста поля
Memo можно и с помощью Буфера обмена (Clipboard).
Метод Insert
Метод вставляет строку с указанным индексом, происходит
перенумерация строк (остальные строки автоматически сдвигаются).
memEx.Lines.Insert(2,''); // добавляет пустую строку на место
строки с индексом 2, которая сдвигается (не пропадает),
Сортировка строк в поле Memo
Сортировка строк осуществляется по следующему алгоритму:
2
Находится место минимальной строки (напоминаем, что строки
сравниваются посимвольно A<B<C ..<Z и т.д.).
Меняются местами первая строка и строка, стоящая на месте
минимальной.
Эти операции производятся (N-1) раз, где N – количество строк в поле
Memo.
Напишем эту программу.
procedure TfrmEx1.btnEx1Click(Sender: TObject);
begin
 //Для каждой i- ой строки из поля просмотра
 //находим место минимальной строки, начиная с i-ого номера
 // меняем ее с текущей.
end.
Описываем необходимые нам переменные, вписываем нужные
операторы языка Паскаль, описываем используемую функцию нахождения
места минимальной строки в поле Memo.
В результате получим следующую программу.
implementation
{$R *.dfm}
function PlMin(numStr:integer):integer;
var
 k,m:integer;
begin
 m:=NumStr; //Пусть строка, стоящая на месте num_str, минимальна
 for k:=m+1 to frmEx1.memEx1.Lines.Count do // Для всех строк,
 начиная с номера num_str
 if frmEx1.memEx1.Lines[k]< frmEx1.memEx1.Lines[m] then
 // Если текущая строка меньше минимальной, то
 m:=k; // Переопределяем место минимальной строки
 PlMin:=m; //Значению функции присваиваем место мин-ной строки
 end ;
procedure TfrmEx1.btnEx1Click(Sender: TObject);
 var
 i,j:integer;
begin
 for i:=0 to memEx1.Lines.Count do //Для каждой строки из поля
 begin // просмотра
 j:=plmin(i); //находим место мин. строки, начиная с i-ого номера
 memEx1.Lines.Exchange(i,j); // меняем ее с текущей.
 end;
end;
end.
3
Задания.
Задание 1.
Заполнить первое поле Memo любыми числами (по одному в каждой
строке).
Написать программу, которая позволяет при нажатии на клавишу все
положительные числа переписать во второе поле Memo, а отрицательные
– в третье.
Задание 2.
Заполнить поле просмотра, введя в него список класса.
Написать программу, которая позволяет при нажатии на клавишу
отсортировать список.
Задание 3.
Заполнить два поля Memo.
Написать программу, которая позволяет при нажатии на клавишу
вывести в третье поле Memo те строки, которые есть и в первом и во
втором полях просмотра, в противном случае вывести сообщение, что
одинаковых строк нет.
Задание 4.
Заполнить поле Memo числами (по одному в каждой строке).
Написать программу, которая позволяет при нажатии на клавишу
отсортировать числа."""
doc_13_python_1 = """
Python.
Введение.
Язык Python разработал голландский программист Гвидо Ван Россум (Guido van
Rossum) в 1991 году. Не подумайте, что язык назван в честь змеи-питона: Гвидо был большим
фанатом британского комедийного сериала «Летающий цирк Монти Пайтона» (англ. Monty
Python’s Flying Circus), и именно оттуда пришло название языка. С тех пор данный язык
проделал большой путь развития. В 2000 году была издана версия 2.0, а в 2008 году - версия
3.0.
В настоящее время в русском языке для обозначения используют два варианта —
«Питон» и «Пайтон».
Python относится к интерпретируемым языкам программирования: чтобы запустить
написанную на Python программу, нужен интерпретатор Python (его можно скачать
с официального сайта. )
При установке обязательно поставьте галочку Add Python 3.8 to PATH, что
позволит вам пользоваться командой python в командной строке.
Среда разработки.
Команды для интерпретатора можно писать в обычном текстовом редакторе
(например, в «Блокноте»). Но чаще для этого пользуются специальной программой, которая
называется средой разработки (англ.IDE, Integrated Development Environment). Среда
разработки — тоже текстовый редактор, но с дополнительными возможностями. Например,
она умеет сама находить на компьютере программу-интерпретатор и запускать одной
кнопкой. Среда разработки, кроме того, форматирует написанный вами код, чтобы его удобно
было читать, а иногда даже подсказывает, где вы допустили ошибку.
Мы будем использовать среду разработки Wing 101 Python IDE. Ее можно скачать с
сайта разработчика, фирмы Wingware.
Давайте разберемся, как с ней работать. После запуска программы мы увидим
следующую картинку
Чтобы начать писать программу, необходимо создать новый файл File - New
И сразу же его сохранить File – Save As… Тогда среда приобретет следующий вид
При наборе текста программы слева высвечиваются номера строк программы
Инструкция присваивания. Типы данных
Пусть величина degr задает число градусов, а переменная rad — число радиан. Тогда
формула перевода градусов в радианы на языке Python будет выглядеть следующим
образом:
rad = ( degr  3.14 ) / 180
Инструкция присваивания - основная в любом языке программирования. Эта инструкция
позволяет присвоить переменной значение вычисленного выражения.
Инструкция присваивания записывается следующим образом. Слева стоит имя
переменной, справа — выражение, значение которого должно быть вычислено. Разделяет
левую и правую части символ =. Выполнение инструкции присваивания заключается в
следующем: вычисляется результат выражения, стоящего справа, и этот результат
становится значением переменной, имя которой стоит слева.
Формат инструкции присваивания:
<имя переменной> = <арифметическое выражение>
Переменная создается в момент присваивания. Тип переменной определяется
автоматически в соответствии с теми данными, которые ей присваиваются.
Пример 1.
a = 5
b = 3.75
В этом примере переменная a будет целого типа, а переменная b - вещественного.
Существует возможность множественного присваивания
Пример 2.
a = b = c = 10 + 5
В этом случае все три переменные приобретут значение 15.
При выполнении же следующего оператора
a, b, c = 3 + 4, 5 * 7, 2.5
переменные a, b, c приобретут соответственно следующие значения: 7 35 2.5.
Пример 3.
a = 4
b = 7.3
a, b = b, a
В этом примере переменные обменяются значениями. Переменная a после выполнения
этого фрагмента программы примет значение 7.3, а переменная b – значение 4. При этом
изменится и тип переменных. На самом деле, при каждом присваивании создается новая
переменная, а старая с таким же именем уничтожается. То есть в нашем примере
переменные a и b имели значения 4 и 7.3 соответственно. При выполнении последнего
оператора присваивания создались новые переменные a и b со значениями 7.3 и 4
соответственно, а старые переменные уничтожились.
Имя переменной
Имя переменной в языке Python представляет собой последовательность символов,
составленную по следующим правилам:
• символы, используемые в имени, являются либо латинскими буквами, либо
цифрами (от 0 до 9), либо знаком подчеркивания;
• первый символ в имени может быть только буквой или знаком подчеркивания;
В Python заглавные и прописные буквы считаются разными.
Примеры имен переменных: K2, xyz, MaxMin, maxmin, t101z14, NUMBER10.
Обратите внимание, что переменные MaxMin и maxmin – это разные переменные.
Название переменной не должно совпадать с названием ключевых слов языка Python.
Ключевые слова: and, as, assert, break, class, continue, def, del, elif, else, except, False,
finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return,
True, try, while, with, yield.
Арифметическое выражение
Арифметическое выражение — это совокупность констант, переменных, функций,
объединенных знаками арифметических действий и круглыми скобками, имеющая
математический смысл.
Операции, используемые в арифметических выражениях:
Знак Операция Тип операндов Тип результата
+ сложение хотя бы один из операндов вещественный вещественный
оба операнда целые целый
-
вычитание хотя бы один из операндов вещественный вещественный
оба операнда целые целый
*
умножение хотя бы один из операндов вещественный вещественный
оба операнда целые целый
/
деление не зависит от типа операндов вещественный
**
возведение
в степень
хотя бы один из операндов вещественный вещественный
оба операнда целые целый
Вывод информации на экран
Для вывода информации на экран служит функция вывода print().
Формат функции вывода:
print( <список вывода> ) ;
Список вывода может содержать: текст, заключенный в апострофы или кавычки,
переменные, арифметические выражения, логические выражения, а также специальные
параметры. В качестве разделителя в инструкции вывода используется запятая.
При выполнении функции вывода, текст, указанный в апострофах или кавычках, будет
выведен на экран без изменений, а вместо переменных или выражений будет выведены их
значения. Выводимые значения отделяются друг от друга пробелом.
Примеры
a = 4
b = 7.3
print(a, b + 4, "Привет!")
На экран выведется
4 11.3 Привет!
a = 4
b = 7.3
print(a)
print(b)
На экран выведется
4
7.3
Для того, чтобы отделять данные при выводе не пробелом, а другими символами
используется параметр sep. Например,
a = 4
b = 7.3
print(a, b + 4, "Привет!", sep='---')
На экран выведется
4---11.3---Привет!
Для того, чтобы выводимые данные выводились без разделителей вообще,
необходимо параметру sep присвоить пустую строку.
a = 4
b = 7.3
print(a, b + 4, "Привет!", sep='')
На экран выведется
411.3Привет!
Для того, чтобы в конце строки поставит определенные символы служит параметр end.
print(a, b, sep='+', end='=')
print(a + b)
На экран будет выведено
4+7.3=11.3
Обратите внимание, что строка не только закончилась знаком равно, но и не
произошло перевода на другую строку (после выполнения первой функции print курсор
остался на той же строке, а следующая функция print продолжила вывод там же).
Соответственно, если необходимо, чтобы следующая функция выводила информацию на той
же строке, что и предыдущая, необходимо использовать параметр end. При этом, если нет
необходимости завершать строку особым символом, то параметру end необходимо
присвоить пустую строку.
Комментарии
Для того, чтобы поместить комментарии в программе чаще всего используется символ
решетки (#). Любой текст, помещенный после этого знака и до конца строки будет считаться
комментарием.
# Вывод сообщения на экран
print("Добрый день!")
print("Добрый день!") # Вывод сообщения на экран
Однако если необходимо закомментировать большой фрагмент текста, то удобно
использовать другой способ комментирования, а именно три апострофа, размещенные на
отдельной строке.
В данном примере текст, расположенный на строках с 3 по 8, будет считаться
комментарием.
Встроенные функции
Как и в других языках программирования, в Python имеется ряд встроенных функций.
Рассмотрим некоторые из них.
Функция int().
Преобразует данные любого типа к целому.
Пример Результат
print(int(23.976)) 23
print(int(5-7.25)) -2
print(int('243')) 243
print(int('12'+"17")) 1217
Функция float().
Преобразует данные любого типа к вещественному.
Пример Результат
print(float(5)) 5.0
print(float(24*10)) 240.0
print(float("1.745")) 1.745
print(float('12' + "17")) 1217.0
Функция str().
Преобразует данные любого типа к строковому.
Пример Результат
print(str(24 * 10) + '!') 240!
print(str(3 + 2) + str(2 - 7)) 5-5
print('4/2=' + str(4 / 2)) 4/2=2.0
print(str(12 + 5) * 5) 1717171717
Обратите внимание на последний пример. Если строку умножить на некоторое целое
положительное число, то строка повторится указанное число раз. При сложении строк строки
склеиваются, так же, как и в других языках программирования."""
doc_14_python_2 = """
Python.
Деление нацело и остаток от деления.
В языке Python для обозначения операции целочисленного деления используется
следующая комбинация символов // (два слэша без пробела).
print(20 // 3)
Результат 6.
Для обозначения операции остатка от деления используется следующая символ %
(знак процента).
print(20 % 3)
Результат 2.
Рассмотрим особенности работы этих операторов в языке Python.
Логика работы этих операторов зависит от знака делителя.
Если делитель положительный, то результатом целочисленного деления a // b будет
такое максимально возможное число c, что будет выполняться неравенство c * b <= a.
20 // 3 = 6 (6 * 3 = 18, 18 < 20)
-20 // 3 = -7 (-7 * 3 = -21, -21 < -20)
При этом остатком от деления будет такое число d >= 0, при котором будет
выполняться равенство c * b + d = a.
20 % 3 = 2 (6 * 3 + 2 = 20)
-20 % 3 = 1 (-7 * 3 + 1 = -20)
Если делитель отрицательный, то результатом целочисленного деления a // b будет
такое минимально возможное число c, что будет выполняться неравенство c * b >= a.
20 // -3 = -7 (-7 * -3 = 21, 21 > 20)
-20 // -3 = 6 (6 * -3 = -18, -18 > -20)
При этом остатком от деления будет такое число d <= 0, что будет выполняться
равенство c * b + d = a.
20 % -3 = -1 (-7 * -3 -1 = 20)
-20 % -3 = -2 (6 * -3 -2 = -20)
Заметим, что в языке Python знак остатка от деления всегда совпадает со знаком
делителя.
Операции целочисленного деления и остатка от деления имеют указанный смысл
только если оба операнда являются целыми числами. Язык Python допускает использование
и вещественных чисел, однако смысл использования данных операций в этом случае
теряется.
Арифметические операции с присваиванием
В языке Python могут быть использованы операции присваивания следующего вида:
a <арифметический оператор> <знак равно> b
Такая запись эквивалентна следующему выражению
a <знак равно> a <арифметический оператор> b
Например
a += b равносильно a = a + b
a %= b равносильно a = a % b
Допустимы следующие операции
+= присвоение результата сложения
-= присвоение результата вычитания
*= присвоение результата умножения
/= присвоение результата от деления
**= присвоение степени числа
//= присвоение результата целочисленного деления
%= присвоение остатка от деления
Ввод данных
Для ввода данных используется функция input().
n = input()
При вызове этой функции выполнение программы приостанавливается. Происходит
ожидание ввода данных. После набора на клавиатуре некоторого текста и нажатия клавиши
ввода, набранный текст присваивается переменной n.
Допускается в круглых скобках указать некоторый текст, заключённый в апострофы или
кавычки. В этом случае при приостановке программы на экране высвечивается данный текст
в виде подсказки.
n = input('введите значение:')
print(n)
При выполнении этого фрагмента программы на экране можно будет увидеть
следующее
введите значение:23
23
Немного исправим программу
n = input('введите значение:')
print(3 * n)
Получим следующий результат
введите значение:23
232323
Дело в том, что функция input() возвращает всегда строку. Если нам необходимо
ввести численные значения, то надо воспользоваться функциями преобразования int() или
float(), соответственно для целых и вещественных данных.
n = int(input('введите значение:'))
print(3 * n)
Получим следующий результат
введите значение:23
69
Работа с другими системами счисления
В языке Python есть возможность переводить целые числа из произвольной системы
счисления (не белее 36-ричной) в десятичную. Для этого служит функция int(), с двумя
параметрами. Первый параметр – это строка, содержащее число, записанное в некоторой
системе счисления, а второй параметр – основание системы счисления, в которой записано
число.
Например,
n = int('1001', 2)
print(n)
n = int('FF', 16)
print(n)
n = int('20', 36)
print(n)
В результате получим
9
255
72
Функции, которая бы переводила числа из десятичной системы в произвольную, в
языке Python нет.
Однако есть возможность работать с целыми числами в двоичной, восьмеричной и
шестнадцатеричной системах счисления.
Для записи числа в одной из этих систем счисления перед его значением в качестве
префикса ставится цифра 0 и соответствующая латинская буква:
b – для двоичных чисел;
o – для восьмеричных чисел;
x – для шестнадцатеричных чисел;
Примеры:
0b1001 – запись двоичного числа 1001
0o177 – запись восьмеричного числа 177
0xFF – запись шестнадцатеричного числа FF
Такие числа могут участвовать в арифметических выражениях и операциях
присваивания. При этом системой автоматически подставляется их десятичное значение.
В результате работы следующей программы
n = 0b1001
print(n)
n = 0xF0 + 0x10
print(n)
получим
9
256
Имеется возможность перевести десятичное число в двоичное, восьмеричное и
шестнадцатеричное представление. Для этого служат функции bin(x), oct(x) и hex(x)
соответственно.
Например, после выполнения следующего фрагмента программы
n = 0xF0 + 0x10
print(n)
s = bin(n)
print(s)
s = oct(n)
print(s)
s = hex(n)
print(s)
будет получен следующий результат
256
0b100000000
0o400
0x100
Важно, отметить, что тип результата этих функция – строка. Поэтому следующий
пример
s = bin(2) + bin(2)
print(s)
даст результат
0b100b10
То есть, склеилось две строки, каждая из которых содержала двоичную запись числа
2.
А в результате выполнения следующей программы
s = 0b10 + 0b10
print(bin(s))
будет выведено
0b100
Складывается десятичное представление двух двоичных чисел со значением два.
Результат – число 4. Выводится его двоичное представление.
Встроенные функции
Имеется ряд функций, встроенных в язык Python. С некоторыми из них мы уже знакомы.
Например, int(), float(), bin() и т.д.
Познакомимся еще с несколькими полезными встроенными функциями
Функция Назначение
Входные
параметры
Тип
результата
Примеры
abs( x ) Возвращает
абсолютное
значение (модуль)
аргумента
x - значение
типа int или
float
Такой же, как
и тип
аргумента
abs (-2.745) = -2.745
abs (34) = 34
pow(x, y[, r]) (x ** y) % r,
взятие остатка
возможно только
в случае целых x,
y
x, y - значение
типа int или
float
r - значение
типа int
Тип
результата
аналогичен
операции **
pow(4,2) = 16
pow(4.0,2) = 16.0
pow(4,2,3) = 1
max(a[, b[, c[,
...]]])
Возвращает
максимальный
элемент из a, b, c,
....
a, b, c, … -
значение типа
int или float
Такой же, как
и тип
элемента,
оказавшегося
максимальны
м
max(4.5, 2, 5) = 5
max(3.6, 2, 7.2, 4) = 7.2
min(a[, b[, c[,
...]]])
Возвращает
минимальный
элемент из a, b, c,
....
a, b, c, … -
значение типа
int или float
Такой же, как
и тип
элемента,
оказавшегося
минимальны
м
min(4.5, 2, 5) = 2
min (3.6, 1.7, 7.2, 2) = 1.7
round(X) Возвращает
округлённое по
модулю до
ближайшего
целого значение
числа X
X - значение
типа int или
float
значение типа
int
round ( 3.1 ) = 3;
round ( -3.1 )= -3;
round ( 3.8 ) = 4;
round ( 3.5 ) = 4;
round ( 2.5 ) = 2;
round ( -3.8 )= -4;
round(X, N) Округление до N
знаков после
запятой
X - значение
типа int или
float
N- значение
типа int
Такой же, как
и тип
аргумента X
round(21.1234, 2) = 21.12
round(-21.783, 1) = -21.8
round(-21.783, 10) = -21.783
round(2, 5) = 2
Работа с модулями
Мы познакомились с некоторыми встроенными функциями в язык Python. Их
количество ограничено наиболее часто употребимыми. Но язык Python позволяет
подключать дополнительные наборы функций. Для этого используются готовые модули.
Рассмотрим для примера модуль math. Этот модуль содержит много функций,
полезных при выполнении математических вычислений.
Для того, чтобы начать работать с модулем, его необходимо подключить. Для этого
служит оператор import.
Существует несколько способов подключения модуля. Рассмотрим их.
1. import math
В этом случае подключается весь модуль. Для обращения к конкретной функции
модуля используется следующий синтаксис:
< имя модуля > < точка > < имя функции >
import math
x = math.trunc(123.9)
print(x)
В данном случае будет использована функция целой части числа trunc(), которая
встроена в модуль math.
2. Возможно использовать синоним имени модуля для более краткой записи
import math as m
x = m.trunc(123.9)
print(x)
Здесь имя m заменяет название модуля.
3. Если нужны не все функции модуля, а только несколько конкретных, то можно это
сделать следующим образом:
from math import sin, trunc
x = trunc(123.9)
print(x)
В этом примере из модуля math импортируется только две функции sin() и trunc(). В
этом случае уже нет необходимости ссылаться на сам модуль при вызове функции.
4. Для того, чтобы пользоваться всеми функциями модуля, не ссылаясь на него,
можно воспользоваться еще одним способом подключения модуля.
from math import *
x = trunc(123.9)
print(x)
Однако при таком способе подключения надо помнить, что некоторые функции могут
иметь одинаковое имя со встроенными функциями и перекрывать их. Например, функция
pow(), в модуле math работает несколько иначе по сравнению с со встроенной функцией
pow().
Так как модуль math имеет много полезных функций, то ниже приведен список функций,
входящих в него.
Список функций, входящих в модуль math.
math.ceil(X) – округление до ближайшего большего числа.
math.copysign(X, Y) - возвращает число, имеющее модуль такой же, как и у числа X, а знак - как у
числа Y.
math.fabs(X) - модуль X.
math.factorial(X) - факториал числа X.
math.floor(X) - округление вниз.
math.fmod(X, Y) - остаток от деления X на Y.
math.frexp(X) - возвращает мантиссу и экспоненту числа.
math.ldexp(X, I) - X * 2i
. Функция, обратная функции math.frexp().
math.fsum(последовательность) - сумма всех членов последовательности. Эквивалент встроенной
функции sum(), но math.fsum() более точна для чисел с плавающей точкой.
math.isfinite(X) - является ли X числом.
math.isinf(X) - является ли X бесконечностью.
math.isnan(X) - является ли X NaN (Not a Number - не число).
math.modf(X) - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.
math.trunc(X) - усекает значение X до целого.
math.exp(X) - e
X
.
math.expm1(X) - e
X
- 1. При X → 0 точнее, чем math.exp(X)-1.
math.log(X, [base]) - логарифм X по основанию base. Если base не указан, вычисляется натуральный
логарифм.
math.log1p(X) - натуральный логарифм (1 + X). При X → 0 точнее, чем math.log(1+X).
math.log10(X) - логарифм X по основанию 10.
math.log2(X) - логарифм X по основанию 2. Новое в Python 3.3.
math.pow(X, Y) - X
Y
.
math.sqrt(X) - квадратный корень из X.
math.acos(X) - арккосинус X. В радианах.
math.asin(X) - арксинус X. В радианах.
math.atan(X) - арктангенс X. В радианах.
math.atan2(Y, X) - арктангенс Y/X. В радианах. С учетом четверти, в которой находится точка (X,
Y).
math.cos(X) - косинус X (X указывается в радианах).
math.sin(X) - синус X (X указывается в радианах).
math.tan(X) - тангенс X (X указывается в радианах).
math.hypot(X, Y) - вычисляет гипотенузу треугольника с катетами X и Y (math.sqrt(x * x + y * y)).
math.degrees(X) - конвертирует радианы в градусы.
math.radians(X) - конвертирует градусы в радианы.
math.cosh(X) - вычисляет гиперболический косинус.
math.sinh(X) - вычисляет гиперболический синус.
math.tanh(X) - вычисляет гиперболический тангенс.
math.acosh(X) - вычисляет обратный гиперболический косинус.
math.asinh(X) - вычисляет обратный гиперболический синус.
math.atanh(X) - вычисляет обратный гиперболический тангенс.
math.erf(X) - функция ошибок.
math.erfc(X) - дополнительная функция ошибок (1 - math.erf(X)).
math.gamma(X) - гамма-функция X.
math.lgamma(X) - натуральный логарифм гамма-функции X.
math.pi - pi = 3,1415926...
math.e - e = 2,718281..."""
doc_15_python_3 = """Python.
Логические выражения. Логические операции.
В правой части инструкции присваивания может стоять не только
арифметическое выражение, но и выражение другого типа, например, логического.
Логическое выражение — это совокупность арифметических выражений,
объединенная логическими операциями и операциями отношения и принимающее
только 2 значения — True (правда) или False (ложь) (0 или 1). True и False пишутся
только с большой буквы.
Наименование "булевский" выбрано в честь английского математика Джорджа
Буля, заложившего основы математической логики. Термины булевский и логический
обычно употребляются как синонимы. В Python этот тип имеет название bool.
Пример 1.
a = True
print(a)
В этом примере переменная a будет типа bool, а в результате работы программы
будет выведено True.
Как уже говорилось, логическое выражение может включать в себя:
арифметические выражения, операции отношения и логические операции. Что такое
оперции отношения и логические операции?
Операции отношения
Операции отношения предназначены для сравнения двух величин. Результат
сравнения имеет значение True или False.
== — равно
!= — не равно
< — меньше
<= — меньше или равно
> — больше
>= — больше или равно
Пример 2.
x = 2
ok = x > 0
exist = x == 3 - 27
В результате выполнения этой программы переменная ok примет значение True,
а переменная exist — значение False.
Логические операции
Логические операции применяются к величинам логического типа, результатом
выполнения операции тоже является величина логического типа.
Рассмотрим следующие логические операции:
− not (отрицание, унарная операция)
− and (и) (логическое умножение)
− or (или) (логическое сложение).
Таблица значений логических операций
X Y not X X and Y X or Y
False False True False False
False True True False True
True False False False True
True True False True True
Значение выражения вычисляется в определенном порядке.
Таблица приоритета выполнения операций
Тип действий Операции
Вычисления в круглых скобках ( )
Вычисления значений функций функции
Операция возведения в степень **
Унарные операции унарный “-”
Операции типа умножения *, /, //, %
Операции типа сложения +, -
Операции отношения ==, !=, <, >, <=, >=, is, is not
Логическое отрицание not
Логическое умножение and
Логическое сложение or
Операции одинакового приоритета выполняются слева направо в порядке их
следования в выражении.
Пример 3.
a = 17 // 5 * 5 + (17 % 5)
b = 4 + abs(-5 + 9)
c = a < 3
d = a * 2 > b or not a - 1 > 10 and c
print(d)
В результате работы программы будет выведено True.
В качестве примера рассмотрим еще одну задачу. Пусть заданы координаты
точки (x, y) на плоскости. Определить, попадает ли точка в заштрихованную область.
Если попадает, то вывести True, в противном случае – False.
x = float(input('Введите координату X: '))
y = float(input('Введите координату Y: '))
c = (x > 0) and (y > 0)
print(c)
Математическая запись -4 < x ≤ 18.3 на языке Python запишется в виде: x > -4
and x<=18.3.
Допустимо и такое описание -4 < x <= 18.3.
Например, следующая программа
x = 5
y = x < 10 < x*10 < 100
print(y)
выведет True
Хоть множественные неравенства и допустимы в языке Python, лучше не
злоупотреблять этой возможностью.
Приведение типов.
В некоторых случаях python автоматически умеет приводить типы данных, но для
явного приведения данных к типу bool необходимо использовать функцию bool().
При применении функции bool() к любому числу отличному от нуля (как целому,
так и вещественному) будет получен результат True, и только при нулевом значении
аргумента будет получен результат False.
Например, при выполнении следующей программы
print(bool(1))
print(bool(27/45))
print(bool(2**17))
print(bool(-0.00001))
все 4 раза будет выведено True.
При выполнении же программы
print(bool(0))
print(bool(0.00))
print(bool(2-2))
print(bool(101.1-101.1))
четыре раза будет выведено False.
При преобразовании логического значения в целое число получим 1, если
логическое значение True, в противном случае - 0.
При преобразовании логического значения в вещественное число получим
соответственно 1.0 и 0.0.
Организация ветвлений в программе
В жизни мы часто встречаемся с проблемой выбора. Например, если на улице
холодно, мы надеваем пальто, иначе — надеваем плащ. Эту ситуацию можно
представить в виде следующей схемы:
На улице
холодно
Надеть
плащ
Надеть
пальто
ложь истина
В зависимости от истинности утверждения в ромбе “на улице холодно”
выполняется либо действие “надеть пальто”, либо действие “надеть плащ”.
Такая структура называется структурой ветвления
Ситуация, связанная с выбором одной из двух альтернатив, встречается в
программировании довольно часто. В языке Python структуре выбора соответствует
инструкция if ... : ...else : … .
Формат описания:
if <логическое выражение> :
 <инструкция 1.1>
 <инструкция 1.2>
…
 <инструкция 1.n>
else:
 <инструкция 2.1>
 <инструкция 2.2>
…
 <инструкция 2.m>
Порядок выполнения инструкции if ... : ...else : …
• сначала вычисляется значение логического выражения,
• если значение выражения True, то
выполняются инструкции с 1.1 по 1.n,
• иначе (если значение выражения False),
выполняются инструкции с 2.1 по 2.m,.
Обратите внимание на синтаксис написания оператора. if и else должны иметь
одинаковый отступ. После логического выражения и слова else должно стоять
двоеточие. Инструкции долдны иметь отступ вправо на 4 позиции относительно if
(правда многие современные среды допускают отступ и на другое количество позиций,
но в любом случае все инструкции внутри if или else должны иметь одинаковый
отступ).
Иногда структура выбора выглядит несколько иначе:
На улице
дождь
Выйти на
улицу
Взять
зонт
ложь истина
Такой структуре в языке Python соответствует краткая инструкция if....
Формат описания:
if <логическое выражение> :
 <инструкция 1.1>
 <инструкция 1.2>
…
 <инструкция 1.n>
Краткая инструкция выполняется аналогично полной, то есть вычисляется
значение логического выражения, если его значение True, то выполняются
инструкции с 1.1 по 1.n, иначе выполняется следующая за блоком if... инструкция.
Инструкции, находяциеся внутри веточки if или else, сами могут быть
инструкциями выбора, в этом случае инструкция if... называется вложенной.
Например,
if <логическое выражение 1> :
<инструкция 1>
else :
if <логическое выражение 2> :
<инструкция 2>
else:
<инструкция 3>
Каждая из инструкций (инструкция 1, инструкция 2, инструкция 3) может быть
также составной.
В некоторых случаях вместо вложенных инструкций if удобно использовать
какскадные операторы if.
if <логическое выражение 1> :
<инструкция 1>
elif <логическое выражение 2> :
<инструкция 2>
elif <логическое выражение 3> :
<инструкция 3>
…
elif <логическое выражение n> :
<инструкция n>
else:
<инструкция x>
Логика работы данного оператора следующая.
Если, логическое выражение 1 истинно, то выполняется инструкция 1, в
противном случа вычисляется значение логического выражения 2 и т.д. Ели все
логические выражения ложь, то выполняется инструкция x. Веточка else может
отсутствовать, тогда не выполняется никакая инструкция из каскадного оператора
ветвления, а упраление переходит на первую строчку после этого оператора. И,
конечно, на месте любой из инструкций может стоять любое количество инструкций (в
том числе и операторов выбора).
Тернарная условная операция
Иногда бывают ситуации, когда некая переменная в зависимости от условий
может принимать только одно из двух значений.Например, если ученик набрал более
50 баллов, то он сдал зачет, и переменная itog должна получить значение 5, в
противном случае в переменную itog должно быть записано число 2.
Программа могла бы выглядеть следующим образом.
x=int(input('Введите количество баллов'))
if x>50:
 itog = 5
else:
 itog = 2
print(itog)
Однако существует более короткая запись
x=int(input('Введите количество баллов '))
itog = 5 if x>50 else 2
print(itog)
В последней программе применена тернарная условная операция 5 if x>50 else 2.
Любая тернарная условная операия может быть частью выражения, а так же может
быть вложена в другую тернарную условную операцию."""
doc_16_lazarus_random_array = """
Генератор случайных чисел. Константы. Описание собственных
типов. Массивы и правила работы с ними
Функция RANDOM
Для того чтобы получить в программе случайное число необходимо
использовать функцию Random, которая имеет два формата:
 функция Random без параметров возвращает вещественное
случайное число в диапазоне от 0 до 1 (0 – включается, 1 – не включается);
 функция Random(N) возвращает целое случайное число
в диапазоне от 0 до N-1, где N — целое.
Если необходимо задать случайное целое число в диапазоне от a до b
включительно, то надо воспользоваться формулой:
Random(b-a+1)+a.
Если необходимо задать случайное вещественное число в диапазоне от a до
b (a – включено, b – не включено), то надо воспользоваться формулой:
(b-a) * Random+a.
В общем случае, при каждом вызове программы получается один и тот же
набор случайных чисел.
Для того, чтобы каждый раз при запуске программы получался разный набор
случайных чисел, необходимо использовать процедуру Randomize. Вызов
процедуры Randomize должен быть оформлен таким образом, чтобы она
выполнялась только один раз в программе.
Именованные константы
Константами называются величины, которые не меняются в процессе
выполнения программы. Константы, так же как и переменные, имеют свой тип.
Константы бывают неименованные и именованные.
Примеры неименованных констант:
100 — Integer
2.7 — Real
7.12457е-03 — Real
TRUE — Boolean
14.0 — Real
-37 — Integer
‘asderc’ — String
В некоторых случаях удобно использовать именованные константы. Для
этого в блоке объявлений программы задаётся имя константы и её значение.
Формат описания именованных констант:
Const
<имя константы> = <значение>;
Имя константы задаётся по тем же правилам что и имя переменной. Тип
именованной константы определяется автоматически в соответствии с типом её
значения.
Именованные константы обычно используют для наглядности и для
настройки программы.
Собственные типы
В языке Delphi имеется возможность описывать новые типы.
Пример описания собственных типов:
type
kg = integer;
cm = integer;
var
Weight : kg;
Size : cm:
Что даёт нам использование собственных типов? Во-первых, лучшее
понимание программы, наглядность. Кроме того, если в дальнейшем окажется,
что мы неудачно выбрали тип для описания переменных то достаточно поменять
тип только в одном месте, а не во всех местах, где мы описывали переменные.
Одномерные массивы
Массив – это совокупность данных одного типа, имеющая одно общее имя,
но разные индексы и значения. Например, список учащихся класса. Имя каждого
элемента данного массива – это «Ученик», в журнале каждому ученику присвоен
номер – это индекс элементов массива, а вот кто этот ученик – это значение
элемента массива.
Формат описания массива:
<имя массива> : Array [<нач. зн>. ..< кон. знач. индекса>] Of <тип эл-в> ;
Описание массива включает в себя:
 имя массива;
 ключевое слово Array;
 начальное и конечное значение индекса, которые определяют границы
изменения индексов, например: 1..40, -2..2, 0..10. Нижняя граница показывает
наименьшее возможное значение индекса, верхняя - наибольшее. Очевидно,
что нижняя граница не может превосходить верхнюю. Нижняя граница
отделяется от верхней двумя точками. Индекс должен иметь порядковый тип
(это такой тип, для элементов которого определён предыдущий и
последующий элементы). Из них нам пока известны: все целочисленные типы,
логический тип. В качестве индекса могут выступать только константы, то есть
размер массива задаётся при написании программы и не может быть изменён
в ходе работы программы;
 тип элементов массива.
Пример описания массива
A: array[1..10]of real;
Это массив A, состоящий из 10 элементов, каждый из которых является
вещественным числом.
Важно, что к элементу массива можно обращаться по индексу. При этом
индекс может быть выражением соответствующего типа.
Например
X:=5;
A[x+2]:=4.5
Здесь элементу массива со значение индекса равным 7 (5+2), присваивается
число 4.5.
Использование обращения по индексу позволяет эффективней решать
задачи. Например, чтобы присвоить всем элементам массива ноль достаточно
написать следующий цикл
For i:=1 To 10 do
 A[i]:=0;
Для того, чтобы массив можно было передать в качестве параметра в
процедуру, он должен быть обязательно описан собственным типом, например
Type
 Mas = array[1..30] of integer;
…………………..
…………………..
Var
 A : mas;
Теперь рассмотрим задачу заполнения массива, содержащего N элементов,
значения которых находятся в указанном диапазоне, вывода массива в поле
Мемо и нахождение максимального элемента.
Запишем алгоритм решение задачи в комментариях.
Begin
 //Вводим диапазон chB и chE изменения значений элементов массива
 //Заполняем массив A числами из указанного диапазона
 //Выводим массив в поле Memo
 //Находим максимальный элемент массива Amax.
 //Выводим его
End.
Сопоставим каждой фразе алгоритма операторы языка Lazarus.
Begin
Vvod(chB,chE); //Вводим диапазон chB и chE изменения значений элементов массива
Zapoln(a,chB,chE); //Заполняем массив A случайными числами в диапазоне от chB до chE
Vyvod(a,n); // Выводим массив A, состоящий из n элементов.
Amax:=max(a); // Находим максимальный элемент массива Amax
lblOtv.Caption:=IntToStr(Amax); // Выводим его
End.
Прежде, чем описать необходимые нам для решения задачи процедуры и
функции, отметим, что для того, чтобы передавать массив как параметр
процедуры, необходимо описать собственный тип массив. Решение задачи будет
выглядеть следующим образом.
Const
n=20;
Type
massiv=array[1..n] of integer;
procedure Vvod(var ch1,ch2:integer);
begin
ch1:=StrToInt(frmMas.edtCh1.Text);
ch2:=StrToInt(frmMas.edtCh2.Text);
end;
procedure Zapoln(var a:massiv; chB,chE:integer);
var
i:integer;
begin
randomize;
For i:=1 to n do
 a[i]:=random(chE-chB)+chB;
end;
procedure vyvod(a:massiv; n:integer);
var
i:integer;
begin
frmMas.mem_ish.Lines.Clear;
for i:=0 to n-1 do
 frmMas.memIsh.Lines.Append(IntToStr(a[i+1]));
end;
function max(a:massiv):integer;
var
i,m:integer;
begin
m:=a[1];
for i:=1 to n do
 if a[i]>m then
 m:=a[i];
max:=m;
end;
procedure TfrmMas.btnClick(Sender: TObject);
var
chB,chE:integer;
Amax : integer;
A : massiv;
 begin
Vvod(chB,chE); //Вводим диапазон chB и chE изменения значений элементов
 //массива
Zapoln(a,chB,chE); //Заполняем массив A случ. числами в диапазоне от chB до chE
Vyvod(a,n); // Выводим массив A, состоящий из n элементов.
Amax:=max(a); // Находим максимальный элемент массива Amax.
lblOtv.Caption:=IntToStr(Amax); // Выводим его
 end;
end.
Сортировка массивов. Сортировка простым выбором
Сортировка – это упорядочивание чего-либо по какому-нибудь признаку. Для
сортировки элементов массива существует очень много алгоритмов. Мы разберем
один из самых простых и понятных методов (алгоритмов) сортировки – сортировка
простым выбором.
Метод основан на следующем принципе: если массив надо отсортировать по
возрастанию, то выбирается наименьший элемент, он меняется местами с
первым элементом. Затем, среди оставшихся n-1 элементов выбирается
наименьший элемент, он меняется местами со вторым элементом. Эта операция
затем повторяется с оставшимися n-2 элементами, затем с n-3 элементами, пока
не останется только один элемент — наибольший.
Пример сортировки простым выбором может быть представлен в следующем
виде:
41 22 3 44 25 6
 3 22 41 44 25 6
 3 6 41 44 25 22
 3 6 22 44 25 41
 3 6 22 25 44 41
 3 6 22 25 41 44
Рассмотрим сортировку массива по возрастанию. Сначала пишем алгоритм.
//Вводим диапазон chB и chE изменения значений элементов массива
//Заполняем массив A случайными числами в диапазоне от chB до chE
// Выводим массив A, состоящий из n элементов, в первое поле.
// Сортируем массив A по возрастанию.
// Выводим массив A, состоящий из n элементов, во второе поле.
Напишем рядом с каждой строкой алгоритма процедуру с фактическими
параметрами.
procedure TfrmMas.btnGoClick(Sender: TObject);
var
chB,chE:integer;
A : massiv;
begin
Vvod(chB,chE); //Вводим диапазон chB и chE изменения значений элементов массива
Zapoln(a,chB,chE); //Заполняем массив A случайными числами в диапазоне от chB до chE
Vyvod1(a,n); // Выводим массив A, состоящий из n элементов, в первое поле Memo.
SortMas(a); // Сортируем массив A по возрастанию.
Vyvod2(a,n); // Выводим массив A, состоящий из n элементов, во второе поле Memo.
end;
Первые три процедуры подробно разобраны в предыдущем занятии.
Напишем только процедуру сортировки элементов массива по возрастанию (она
почти такая же, как и для сортировки поля Memo).
procedure SortMas(var a:massiv);
var
i:integer;
begin
for i:=1 to n-1 do / /Для каждого элемента массива
 change(a[i],a[NumMin(a,i)]); //Меняем местами текущий элемент и
 //элемент, стоящий на месте минимального,
//начиная с текущего номера.
end;
И теперь перед этой процедурой опишем процедуру обмена местами двух
величин целого типа и функцию нахождения места минимального элемента
массива, начиная с текущего номера элемента.
function NumMin(a:massiv; start:integer):integer;
var
i,m:integer;
begin
m:=start;
for i:=m+1 to n do
 if a[i]<a[m] then
 m:=i;
NumMin:=m;
end;
procedure change(var one, two:integer);
var
temp:integer;
begin
temp:=one;
one:=two;
two:=temp;
end;"""
doc_17_python_4 = """
Python.
Функции (начало).
Как мы уже видели, в языке Python есть стандартные функции, например, round(), int(),
float(). Но также, как и в других языках, имеется возможность создавать собственные функции.
Общий вид описания собственной функции следующий
def имя_функции(параметры):
 оператор1
 оператор2
 …
 операторN
 return результат
После ключевого слова def следует имя функции, обязательно с круглыми скобками, в
которых указываются параметры. Если параметров нет, то скобки все равно обязательно
должны быть. После скобок ставится двоеточие. Тело функции пишется со следующей
строки, обязательно с отступами. Результат, который должна возвратить функция,
записывается после ключевого слова return.
Напишем функцию, которая возвращает 1, если на вход подано положительное число
и 0 в противном случае.
def is_p(x):
 if x > 0:
 return 1
 else:
 return 0
a = int(input())
print(is_p(a))
Обратите внимание, что может быть несколько операторов return. Описание функции
стоит отделять двумя пустыми строчками от основной программы и от описания других
функций.
В языке Python в отличии от языка Паскаль, нет процедур. Однако есть возможность
делать функции, которые ничего не возвращают и вызываются как процедуры. Напишем
функцию, которая будет печатать слово «Привет!», если параметр равен 1 и «Пока!» при
любом другом значении.
def priv(x):
 if x == 1:
 print("Привет!")
 else:
 print("Пока!")
priv(1)
priv(7)
В результате работы данной программы будет напечатано
Привет!
Пока!
Все переменные в функциях локальны. Однако, если некоторой переменой задать
значение до описания функции, она будет видна внутри функции.
z = 20
def summ(x, y):
 return x + y + z
print(summ(1,2))
print(z)
При выполнении этой программы будет напечатано 23 и 20.
Изменим программу
z = 20
def summ(x, y):
 z = 30
 return x + y + z
print(summ(1,2))
print(z)
При выполнении этой программы будет напечатано 33 и 20. Почему?
Дело в том, что при выполнении оператора z = 30 создастся новая переменная z,
которая будет локальна внутри функции. Та же переменная z, которая было создана до
функции, останется неизменной.
Функции могут возвращать не одно, а несколько значений.
def minmax(x, y):
 if x > y:
 return y, x
 else:
 return x, y
a = int(input())
b = int(input())
a, b = minmax(a, b)
print(a, b)
В результате работы программы наименьшее число окажется в переменной a , а
наибольшее – в переменной b.
Вещественные числа.
Естественно, что кроме целых чисел в языке Python используются и вещественные
числа. Для приведения к вещественному типу используется функция float().
a = float(input())
print(2 * a)
Дробная часть отделяется от целой с помощью точки.
Бывает необходимо привести дробное число к целому. Имеется несколько способов
выполнить эту задачу. Конечно, это можно сделать с помощью функции преобразования к
целому числу int(). В этом случае отбрасывается дробная часть.
print(int(2.3214))
print(int(5.987))
print(int(-2.3214))
print(int(-5.879))
При выполнении этой программы будут выведены числа
2
5
-2
-5
Для округления числа до ближайшего целого используется функция round() с одним
параметром
print(round(2.3214))
print(round(5.987))
print(round(-2.3214))
print(round(-5.879))
В этом случае получим
2
6
-2
-6
Однако при выполнении следующей программы
print(round(4.5))
print(round(5.5))
print(round(-4.5))
print(round(-5.5))
получим
4
6
-4
-6
Дело в том, что при дробной части равной 0.5 округление происходит до ближайшего
четного числа.
Если использовать функцию round() с двумя параметрами, то второй параметр будет
указывать до какого знака после запятой будет округлено число.
print(round(1.23456789,5))
print(round(1.23456789,4))
print(round(1.23456789,2))
print(round(1.23456789,1))
будет напечатано
1.23457
1.2346
1.23
1.2
Если второй параметр сделать отрицательным, то число будет округляться до
десятков, сотен, тысяч и т. д.
print(round(1234567.89,-1))
print(round(1234567.89,-2))
print(round(1234567.89,-4))
print(round(1234567.89,-5))
получим
1234570.0
1234600.0
1230000.0
1200000.0
Если нет необходимости округлять числа, а надо только ограничить количество знаков
при выводе, можно воспользоваться функцией format().
В общем виде синтаксис записи этой функции выглядит следующим образом
format(value, format_spec)
где
• value - форматируемое значение,
• format_spec - спецификации формата
Есть много вариантов спецификации, однако мы пока рассмотрим только два.
format_spec – ‘это строка, содержащая некоторые значения, которые указывают как
будет отформатировано значение value (в нашем случае вещественное число).
Спецификация вида точка число буква f указывает сколько знаков после точки будет
выведено.
Например
a = 234.123456789
print(format(a,'.5f'))
print(format(a,'.0f'))
print(format(a,'.1f'))
print(format(a,'.4f'))
print(format(a,'.13f'))
print(format(a,'.14f'))
print(format(a,'.15f'))
print(format(a,'.20f'))
получим
234.12346
234
234.1
234.1235
234.1234567890000
234.12345678899999
234.123456788999988
234.12345678899998802081
Заметим, что если знаков после точки меньше, чем в исходном числе, то последняя
цифра округляется, если больше, то дописываются нули. Однако при увеличении количества
знаков после точки, возможно некоторое отклонение, как в трех последних строках.
Спецификация вида точка число буква g указывает сколько всего значащих цифр будет
выведено.
Например
a = 234.123456789
print(format(a,'.5g'))
print(format(a,'.0g'))
print(format(a,'.1g'))
print(format(a,'.2g'))
print(format(a,'.3g'))
print(format(a,'.4g'))
print(format(a,'.13g'))
print(format(a,'.14g'))
print(format(a,'.15g'))
print(format(a,'.20g'))
получим
234.12
2e+02
2e+02
2.3e+02
234
234.1
234.123456789
234.123456789
234.123456789
234.12345678899998802"""
doc_18_lazarus_table = """
1
Текстовая таблица (StringGrid)
Для создания таблиц, в ячейках которых располагаются произвольные текстовые
строки, предназначен компонент StringGrid.
Компонент StringGrid находится на вкладке Additional (Дополнительные).
Префикс, который мы будем использовать для имени компонента - sgd. Для примеров
возьмем имя компонента sgdMy.
Таблица делится на две части — фиксированную и рабочую.
Фиксированная часть служит для показа заголовков колонок и рядов, а также для
ручного управления их размерами. Обычно фиксированная часть занимает одну левую
колонку и один верхний ряд таблицы. Однако, с помощью свойств FixedCols и
FixedRows можно задать другое количество фиксированных колонок и рядов (если эти
свойства имеют значение 0, таблица не содержит фиксированной зоны).
Обычно
sgdMy.FixedCols:=1; // Количество фиксированных столбцов = 1
sgdMy.FixedRows:=1; // Количество фиксированных строк = 1
Рабочая часть — это остальная часть таблицы. Она может содержать
произвольное количество колонок и рядов (эти величины могут изменяться
программно). Рабочая часть может не умещаться целиком в пределах окна
компонента, в этом случае в него автоматически помещаются нужные полосы
прокрутки. При прокрутке рабочей области фиксированная область не исчезает, но
меняется ее содержимое — заголовки колонок и рядов.
Основным свойством компонента является свойство Cells — набор ячеек, каждая
из которых может содержать произвольный текст. Конкретная ячейка определяется
парой чисел — номером колонки и номером ряда, на пересечении которых она
находится (нумерация начинается с нуля).
Свойство Cells имеет тип String.
Заполнять ячейки таблицы можно вручную, после запуска программы на
выполнение. Для этого необходимо в окне инспектора объектов открыть свойство
Options, нажав на “+”, и свойству goEditing присвоить значение True.
Можно задавать значения ячеек программно с помощью оператора присваивания,
обращаясь к каждой ячейке по ее индексам, при этом необходимо помнить, что
первый индекс – это номер столбца, а второй – номер строки.
Например:
sgdMy.Cells [1,1] := 'Левая верхняя ячейка рабочей зоны';
sgdMy.Cells [0,0] := 'Nomera : ';
Строка 'Nomera : ' будет записана в самую (вообще) первую ячейку таблицы, т.е. в
первую ячейку фиксированной зоны.
Количество ячеек по каждому измерению определяет пара свойств ColCount
(количество колонок) и RowCount (количество рядов). Значения этих свойств и,
следовательно, размеры таблицы могут меняться как на этапе разработки программы,
так и в ходе ее работы, однако их значения должны быть как минимум на единицу
больше соответственно значений в свойствах FixedCols и FixedRows, определяющих
размеры фиксированной зоны.
В таблице sgdMy установим количество колонок =3 и количество рядов =5.
sgdMy. ColCount:=3;
2
sgdMy. RowCount:=5;
Для задания цвета ячеек фиксированной области используется свойство
FixedColor, а для задания цвета ячеек рабочей области используется свойство Color.
В качестве примера рассмотрим задачу, в которой по нажатию кнопки создается
текстовая таблица, количество столбцов, строк и фиксированных столбцов и строк
вводятся в четыре поля ввода. По нажатию второй кнопки фиксированная зона
закрашивается в зеленый цвет, а по нажатию третьей кнопки рабочая область
закрашивается в красный цвет.
Procedure VVod(var n1, n2, n3, n4: integer);
Begin
n1:=StrToInt(frmTab.edtLine.Text);
n2:=StrToInt(frmTab.edtStolb.Text);
n3:=StrToInt(frmTab.edtFline.Text);
n4:=StrToInt(frmTab.edtFstolb.Text);
End;
Procedure MakeTab(n1, n2, n3, n4: integer);
Begin
frmTab.sgdMy.RowCount:=n2;
frmTab.sgdMy.ColCount:=n1;
frmTab.sgdMy.FixedCols:=n4;
frmTab.sgdMy.FixedRows:=n3;
end;
procedure TfrmTab.btnTablClick(Sender: TObject);
var
nl, ns, nfl, nfs:integer;
begin
Vvod(nl, ns, nfl, nfs); //Ввести количество строк nl, столбцов ns,
 // фикс. строк nfl и фикс. столбцов nfs
MakeTab(nl, ns, nfl, nfs); //Создать таблицу с заданным
 // количеством строк и столбцов
end;
procedure TfrmTab.btnCelRedClick(Sender: TObject);
begin
frmTab.sgdMy.Color:=clRed;
end;
procedure TfrmTab.btnFCGreenClick(Sender: TObject);
begin
frmTab.sgdMy.FixedColor:=clGreen;
end;
Некоторые Полезные Свойства компонента StringGrid
Свойство Описание
BorderStyle: TBprderStyle; Определяет рамку компонента: bsNone — нет
рамки; bsSingle — рамка толщиной 1 пиксел
ColCount: Longlnt; Содержит количество колонок таблицы
DefaultColWidth: Integer; Содержит значение ширины колонки, заданное по
умолчанию
RowCount:: Longlnt; Содержит количество рядов таблицы
3
DefaultRowHeight: Integer; Содержит значение высоты рядов, заданное по
умолчанию
Color: TColor; Определяет цвет рабочей зоны
FixedCols: Integer; Определяет количество колонок фиксированной
зоны
FixedRows: Integer; Определяет количество рядов фиксированной
зоны
FixedColor: TColor; Определяет цвет фиксированной зоны
GridHeight: Integer; Содержит значение высоты таблицы
GridWidth: Integer; Содержит значение ширины таблицы
GridLineWidth: Определяет толщину линий, расчерчивающих
таблицу
Задания.
Задание 1.
Создать таблицу StringGrid, для этого:
В полях ввода задать:
1. Количество строк
2. Количество столбцов
3. Количество фиксированных строк
4. Количество фиксированных столбцов
Для изменения цвета фиксированной зоны создать 3 командных кнопки (для
разных цветов)
Для изменения цвета рабочей зоны создать 3 командных кнопки (для разных
цветов)
Создать поле ввода и 2 командные кнопки.
1 команда кнопка выводит строку с номером, заданным в поле ввода.
2 команда кнопка выводит столбец с номером, заданным в поле ввода.
Вывод строки или столбца осуществляется в поле Memo.
Задание 2.
Создать таблицу StringGrid.
При проведении экспериментальной работы по физике задаются: количество
измерений, цена деления прибора, показания прибора в делениях.
В полях ввода задать:
1. Количество измерений (от 5 до 10).
2. Цена деления.
Показания прибора в делениях заносятся в таблицу с клавиатуры.
Вычислить и занести в таблицу результаты всех измерений, а также минимальное
и максимальное значения.
4
Например, количество измерений = 5, цена деления = 10,
тогда таблица имеет вид:
Номер
измерения
Цена
деления
Измерения Результат Максимальное/
минимальное значения
1 10 83 830 Максимальное
2 10 51 510
3 10 67 670
4 10 49 490 Минимальное
5 10 75 750"""

docks = [doc_1_sting, doc_2_array, doc_3_array_2, doc_4_double_array, doc_5_string_to_int, doc_6_lazarus_start,
         doc_7_code_review, doc_8_button, doc_9_graphic, doc_10_graphic_text, doc_11_memo, doc_12_memo_2,
         doc_13_python_1, doc_14_python_2, doc_15_python_3, doc_16_lazarus_random_array, doc_17_python_4,
         doc_18_lazarus_table]


def dock():
    print("""
Далее будут предложены номера, названия и краткое описание всех документаций, 
которые могут пригодиться, введите необходимый номер или несколько номеров через пробел

1) "Строки" - базовые действия с обычными строками в паскаль (не связанно с Lazarus)
2) "Массивы" - Именованные константы, собственные типы, одномерные массивы: понятие, заполнение, вывод. (не связанно с Lazarus)
3) "Массивы2" - Нахождение максимального, минимального элементов массива. Обмен элементов в массиве. (не связанно с Lazarus)
4) "Двухмерные массивы" - работа с двухмерными массивами. (не связанно с Lazarus)
5) "Строки2" - Работа с численной информацией, перевод integer <-> string. (не связанно с Lazarus)
6) "Знакомство с Lazarus" - основные компоненты, характеристики объектов и тд
7) "Оформление кода" - инструкции по правильному написанию кода
8) "Lazarus Кнопки" обработка нажатий, углубленные характеристики кнопок
9) "Lazarus графика" - QPainBox, кисти, холсты фигуры и тд
10) "Lazarus текст на графическом компоненте" - вывод текста на граф. компонент
11) "Lazarus memo" - поле мемо (lines, count, WordWarp, MaxLength, ScrollBars, Aligment, Delete ...)
12) "Lazarus memo2" - поле мемо (clear, insert, add, append)
13) "Python введение" - настройка IDE, типы данных, переменные, вывод информации, ар. действия 
14) "Python деление" - Деление нацело и остаток от деления.
15) "Python логические выражения" - Логические выражения. Логические операции.
16) "Lazarus Random(), массивы" - Функция рандом, остаток теории по массивам
17) "Python функции" - Функции. Начало
18) "Lazarus таблицы" - Текстовая таблица (StringGrid)

""")

    for d in input("Введите номера: ").split():
        print(docks[int(d) - 1])
        print("=" * 120)


dock()
